
/*__________________________________________________________________________________________________SPI - SERIAL PERIPHERAL INTERFACE_____________________________________________________________________________________________________________________

  THE SPI PROTOCOL
1) The SPI is a synchronous and full duplex communication protocol between a master and several slaves. When we say full duplex, we mean the communication goes both ways.
2) SPI uses two pins for data transfer - SDIN and SDO pins.
3) There is a SCLK pin to synchronize data transfer between two chips.
4) There is a also CE pin which is used to initiate and terminate data transfer. So we have four pins in total.
5) So these pins, SDI is also called MOSI, SDO = MISO, SCLK = SCK,CE=SS.
6) We have two different configurations of SPI. We have the SINGLE SLAVE mode, where you have one master communicating with a single slave.
7) Then we have the MULTIPLE SLAVES mode, where you have a single master communicating with three slaves. All of this is possible with SPI.

  THE SPI PROTOCOL - PIN FUNCTION
1) MOSI - Master Out Slave In.This is used to send data from the master to the slave.
2) MISO - Master In Slave Out.This is used to send data from the slave device to the master.
3) SCK  - Serial Clock. This is used to generate a clock to synchronize data transfer between the master and the slave device. This is generated by the master.
4) SS   - Slave Select line. This is used to select a particular slave in the SPI multiple slaves configuration.
Unlike I2C, SPI slaves have no address. Or SPI devices have no address. You select them using the Slave Select line.

  THE SPI PROTOCOL - HOW IT WORKS
 Let's say we want to transfer data between an SPI master and a slave.
1) Transaction is started by enabling the SCK line.
2) The master sets the SS line of the slave low, the SS line of the particular slave we want to talk to we set that to low.
3) Two registers of the same size are involved in transmission, one in the master and the other one is in the slave. Data is usually shifted out with the MSB(Most Significant Bit) first, while shifting a new LSB(Least-significant bit) into the same register.
   At the same time, data from the slave is shifted into the LSB of the register. By the end of shifting all the register bits out and in, the master and the slave would have exchanged data.
4) If more data needs to be exchanged, the shift registers will be reloaded and the process of exchange will start again.
5) When no more data is to be transmitted, the master stops toggling the SCK line and deselects the slave device.

  THE SPI PROTOCOL - TRANSMISSION
1) Let's see an example, let's say the master wants to send something to the slave and also wants to receive something from the slave, so we are sending 0xD2 and receiving 0x75 when I say sending and receiving i'm talking from the perspective of the master.
  So we set the slave line low,it is the SS line so this will be a GPIO pin just set that pin low.For SCK, we're toggling the SCK because we send data on a particular edge of the SCK. Here we see every rising edge is when the data is sent so rising edge is
  this one here this is a falling edge the edge that brings us to the valley of the square we use the falling edge the edge that takes us to the peak is the rising edge so you see over will be sent on this first rising edge, bit 1 will be sent on the second
  one, bit 2 will be sent on this third one, bit 3 will be sent here on the rising edge.So master out slave in, so this line is used to send data from the master to the slave so on the MOSI line we first set the MOSI line high we set it high when the SCK line
  has its rising edge we are toggling the SCK line we wouldn't be explicitly controlling that we are toggling it so the MOSI line is set high to send the data. So if you want to send one again we remain high but when we want to send zero we set the MOSI low
  zero means low one means high and over here we want to send another one so we set it high and sending happens only at the rising edge.sending is happening only at the rising edge. We can configure it to happen at the falling edge of the SCK. In this example,
 we send in only here. So over here, we send in another 0. Then we send in another 1. And then we send in a 0. Okay. And then the slave also is sending to the master. So this is connected to the MISO line. Master in, slave out. So 0 is received. And then 0
 is received over here. 1 is received. And all this time, the slave select line is set to 0. When we are done dealing with this particular slave, we would set its line back to 1. We would set it high to deselect it.

THE SPI PROTOCOL - CLOCK PHASE AND POLARITY
1) The master and the slave device must agree on the clock phase and the polarity before they can communicate.
2) CPOL  stands for clock polarity and CPHA  stands for clock phase.
3) Combinations of the CPOL and CPHA are referred to as the SPI bus modes.So we have four bus modes.

THE SPI PROTOCOL - BUS MODES
      	   	 CPOL      CPHA
Mode0 ---->	  0          0
Mode1 ---->   0      	 1
Mode2 ---->   1			 0
Mode3 ---->	  1 		 1

1) CPOL = 0 , means sampling on the first edge
Active state of the clock = 1, Idle state of the clock = 0.
CPHA = 0 , then data is captured on the rising edge and data will be put out on the falling edge or data is output on the falling edge.
CPHA = 1 , data is captured on the falling edge and Data is put out on the rising edge or data is output on the rising edge.

2) CPOL = 1  , means sampling on the second edge
Active state of the clock = 0, Idle state of the clock = 1.
CPHA = 0 , then data is captured on the falling edge and data will be put out on the rising edge or data is output on the rising edge.
CPHA = 1 , data is captured on the rising edge and Data is put out on the falling edge or data is output on the falling edge.

THE SPI PROTOCOL - NSS MANAGEMENT
1) NSS software mode - the SS line is driven internally by the firmware.
2) NSS hardware mode -  a dedicated GPIO pin is used to drive the SS line.In the hardware mode, there are two sub-modes.
   (a) NSS Output Enabled -  This is used when the device operates in master mode.
   (b) NSS Output DisableD - This allows multi-master capability for devices operating in master mode

THE SPI PROTOCOL - TI MODE
1) NSS hardware mode must be used.
2) CPHA and CPOL are forced to conform with the Texas Instrument(TI) Protocol requirements.
3) In this mode, NSS signal pulses at the end of every transmitted byte. So, when we go write in our SPI driver, we will be configuring these parameters.*/


#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include  "adxl345.h"

int16_t x,y,z;
float xg,yg,zg;

uint8_t data_rec[1];

/*Inside main, we call our adxl_init function and inside this function both the I2C and the accelerometer will be initialized.Once that is done we're going to call our adxl_read_values function and this function takes the start address as argument.
 Remember we said we want to read all the values. So we want to read from X0 to Z1. We're going to be doing this repeatedly in the infinite loop and once that is done we need to combine X0 and X1 into a single x value. We have  created local
 variables  x,y,z and then xg,yg,zg. When we did our read values, the value read was stored in the buffer, There is a buffer that we created called data_rec .We create an external version because we need access to it's content.Here the first two values
 are the X0 and X1 values,we're going to combine them by shifting them to get a single value called X. We take index 0 and then perform an OR operation with index 1 shifted, this will give us x. We do the same to get y, Y0 and Y1 are located at index 2
 and index 3. So we do the same and then Z0, Z1 are located at index 4 and index 5.This will give us the x,y,z .Now to convert this to g there is a scale factor that we need to multiply this by and this is found in the data sheet.
 This is a constant called the 4g scale factor = 0.0078, we're going to multiply our x,y,z values with this value to get a unit in g.That's why we created this xg, yg, zg variable is to hold a unit in g. */
int main(void){

	adxl_init();
	while(1){
		adxl_read(DATA_START_ADDR,data_rec); //adxl_read for spi takes two arguments
		x = ((data_rec[1]<<8)|data_rec[0]);
		y = ((data_rec[3]<<8)|data_rec[2]);
		z = ((data_rec[5]<<8)|data_rec[4]);
		xg = (x*0.0078);
		yg = (y*0.0078);
		zg = (z*0.0078);


	}

}
/*Click to build , debug as STM32. click to switch. Go to live expression and enter x,y,z,xg,yg,zg. you will see values when you shake your accelerometer.*/
