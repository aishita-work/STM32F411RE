/*___________________________________________________INTER-INTEGRATED CIRCUIT (I2C) PROTOCOL______________________________________________________
The abbreviation I2C stands for Inter-Integrated Circuit.I2C/I^2C has a number of names,we can also call this the Two-Wire Interface or TWI.

I2C LINES
1) SCL: Serial Clock
   This line is for synchronizing the data transfer between the master and the slave.
2) SDA: Serial Data
   The data line.

We have a single I2C connecting two masters to a number of slaves. We have slaves from N-1 all the way to N and then we have pull-up resistors, Rp connecting both the SDA and SCL lines over here to VDD.
So when we are configuring our SDA and SCL lines in code, we shall enable this mode. We shall make sure we either have to connect these resistors externally or we shall enable them internally.

OPERATION MODES
Four operation modes are Master Transmitter , Master Receiver , Slave Transmitter , Slave Receiver.

THE PROTOCOL
1) Transactions are always initiated and completed by the master.
2) All messages have an address frame and a data frame.
3) Data is placed on the SDA line after the SCL line goes low, and it is sampled after the SCL line goes high.We need not remember this to write our I2C driver, but this is just gives an overview of how
   the two lines work, SDA and SCL .

THE PROTOCOL - START and STOP Condition

| Start |     Slave Address      |   R/W   |  ACK  |            Data             |  ACK  |  Stop   |

1) When we start writing our I2C code, we realize that all transactions would have to begin with a START condition and terminate by a STOP condition.
2) A HIGH to LOW transaction on the SDA line while the SCL line is HIGH defines a START condition. What a start condition is? START is a high to low transition on the SDA line.
What we mean by high to low is the pin was set high and we just set it back to when it moves from on to off on the SDA line while the SCL line is high. Then we call this the start condition.
3) A LOW to HIGH transition on the SDA line while the SCL line is HIGH defines a STOP condition.
4) START and sSTOP conditions are always generated by the master.
5) The bus is considered to be free again at a certain time after the STOP condition. So the bus is not free, it's only free after the stop condition.
6) The bus stays busy if a repeated START is generated instead of a STOP condition.
If you see a SDA and SCL diagram(ANY), we have the SCL line staying high then the SDA line moves from high to low. So this transition from high to low indicates our start condition.
So we start with the start condition then we would send the slave address, and then whether we want to write or read(R/W).Then last we have our stop condition, the SCL line is high
 but the SDA line transitions from low to high. So if we are writing bare metal code, we would write set these back to low or set this to high. We would explicitly set these bits high
 and low, but if we are using HAL or if we are using the LL library provided by ST, we simply need to call a function to generate the start and stop conditions for us.

THE PROTOCOL - BYTE FORMAT
1) Any information transmitted on the SDA line must be 8-bit long.
2) The number of bytes that can be transmitted per transfer is unrestricted.
3) Each byte must be followed by an Acknowledge (ACK) bit or known as an Acknowledged Bit.
4) Data is transferred with the Most Significant Bit (MSB) first.

THE PROTOCOL - ADDRESS FORMAT
1) The address frame is first in any new communication sequence. It's the address frame that we use to address the slave that we want to talk to, or we want to communicate with.
 If we have multiple slaves, the only way we identify who we want to talk to is by the address. So the address frame is first.
2) For a 7-bit address, the address is sent out with the MSB sent out first, followed by a R/W bit, which will indicate whether we want to read(1) or write(0).

THE PROTOCOL - DATA FRAME
1) The data frame begins transmission after the address frame is sent.
2) The master will simply continue generating clock pulses on the SCL line at regular interval and the data will be placed on the SDA line by either the master or the slave,
 depending on whether the R/W bit indicated a we  read or write operation. So, if we are writing to the slave, then the data will be placed on the SDA line by the master.
 If we are reading from the slave, then the data will be placed on the SDA line by the slave.

I2C CLOCK SPEED
This is the speed of the I2C interface and should correspond with the bus speed defined by the I2C specification.
In the specifications, the following modes are defined:
1) Standard-mode : 100KHz max
2) Fast-mode: 400KHz max
3) Fast-mode plus: 1MHz
4) High-speed mode: 3.4 MHz

I2C DUTY CYCLE
1) Specifies the ratio between the time low and the time high of the I2C SCL line.Remember we are clocking signals high and low,So the duty cycle specifies how much time we
remain low and how much time we remain high and this is with regards to the SCL line.
2) Possible values are:
 I2C_DUTYCYCLE_2    =  2:1
 I2C_DUTYCYCLE_16_9 =  16:9
3) By choosing the appropriate duty cycle, we can pre-scale the peripheral clock to achieve the desired I2C speed. So,if you see the duty cycle anywhere in the code,
 this is what we are trying to achieve.

______________________________________________________________________________________________________________________________________________________________________________*/

#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include  "adxl345.h"

int16_t x,y,z;
float xg,yg,zg;

extern uint8_t data_rec[1];

/*Inside main, we call our adxl_init function and inside this function both the I2C and the accelerometer will be initialized.Once that is done we're going to call our adxl_read_values function and this function takes the start address as argument.
 Remember we said we want to read all the values. So we want to read from X0 to Z1. We're going to be doing this repeatedly in the infinite loop and once that is done we need to combine X0 and X1 into a single x value. We have  created local
 variables  x,y,z and then xg,yg,zg. When we did our read values, the value read was stored in the buffer, There is a buffer that we created called data_rec .We create an external version because we need access to it's content.Here the first two values
 are the X0 and X1 values,we're going to combine them by shifting them to get a single value called X. We take index 0 and then perform an OR operation with index 1 shifted, this will give us x. We do the same to get y, Y0 and Y1 are located at index 2
 and index 3. So we do the same and then Z0, Z1 are located at index 4 and index 5.This will give us the x,y,z .Now to convert this to g there is a scale factor that we need to multiply this by and this is found in the data sheet.
 This is a constant called the 4g scale factor = 0.0078, we're going to multiply our x,y,z values with this value to get a unit in g.That's why we created this xg, yg, zg variable is to hold a unit in g. */
int main(void){

	adxl_init();
	while(1){
		adxl_read_values(DATA_START_ADDR);
		x = ((data_rec[1]<<8)|data_rec[0]);
		y = ((data_rec[3]<<8)|data_rec[2]);
		z = ((data_rec[5]<<8)|data_rec[4]);
		xg = (x*0.0078);
		yg = (y*0.0078);
		zg = (z*0.0078);


	}

}
/*Click to build , debug as STM32. click to switch. Go to live expression and enter x,y,z,xg,yg,zg. you will see values when you shake your accelerometer.*/

