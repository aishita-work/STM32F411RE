
21_I2C_adxl345.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000d18  08000198  08000198  00001198  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08000eb0  08000eb8  00001eb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08000eb0  08000eb0  00001eb8  2**0
                  CONTENTS
  4 .ARM          00000000  08000eb0  08000eb0  00001eb8  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000eb0  08000eb8  00001eb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000eb0  08000eb0  00001eb0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08000eb4  08000eb4  00001eb4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00001eb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000038  20000000  08000eb8  00002000  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000038  08000eb8  00002038  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00001eb8  2**0
                  CONTENTS, READONLY
 12 .debug_info   000007f8  00000000  00000000  00001ee8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000031a  00000000  00000000  000026e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000000b8  00000000  00000000  00002a00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 0000007b  00000000  00000000  00002ab8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000ea4f  00000000  00000000  00002b33  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000168a  00000000  00000000  00011582  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0005399d  00000000  00000000  00012c0c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  000665a9  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000298  00000000  00000000  000665ec  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000041  00000000  00000000  00066884  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000000 	.word	0x20000000
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08000e98 	.word	0x08000e98

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000004 	.word	0x20000004
 80001d4:	08000e98 	.word	0x08000e98

080001d8 <__aeabi_dmul>:
 80001d8:	b570      	push	{r4, r5, r6, lr}
 80001da:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80001de:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80001e2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80001e6:	bf1d      	ittte	ne
 80001e8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80001ec:	ea94 0f0c 	teqne	r4, ip
 80001f0:	ea95 0f0c 	teqne	r5, ip
 80001f4:	f000 f8de 	bleq	80003b4 <__aeabi_dmul+0x1dc>
 80001f8:	442c      	add	r4, r5
 80001fa:	ea81 0603 	eor.w	r6, r1, r3
 80001fe:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000202:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000206:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800020a:	bf18      	it	ne
 800020c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000210:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000214:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000218:	d038      	beq.n	800028c <__aeabi_dmul+0xb4>
 800021a:	fba0 ce02 	umull	ip, lr, r0, r2
 800021e:	f04f 0500 	mov.w	r5, #0
 8000222:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000226:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 800022a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800022e:	f04f 0600 	mov.w	r6, #0
 8000232:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000236:	f09c 0f00 	teq	ip, #0
 800023a:	bf18      	it	ne
 800023c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000240:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000244:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000248:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 800024c:	d204      	bcs.n	8000258 <__aeabi_dmul+0x80>
 800024e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000252:	416d      	adcs	r5, r5
 8000254:	eb46 0606 	adc.w	r6, r6, r6
 8000258:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800025c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000260:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000264:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000268:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800026c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8000270:	bf88      	it	hi
 8000272:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000276:	d81e      	bhi.n	80002b6 <__aeabi_dmul+0xde>
 8000278:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 800027c:	bf08      	it	eq
 800027e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000282:	f150 0000 	adcs.w	r0, r0, #0
 8000286:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800028a:	bd70      	pop	{r4, r5, r6, pc}
 800028c:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8000290:	ea46 0101 	orr.w	r1, r6, r1
 8000294:	ea40 0002 	orr.w	r0, r0, r2
 8000298:	ea81 0103 	eor.w	r1, r1, r3
 800029c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80002a0:	bfc2      	ittt	gt
 80002a2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80002a6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80002aa:	bd70      	popgt	{r4, r5, r6, pc}
 80002ac:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80002b0:	f04f 0e00 	mov.w	lr, #0
 80002b4:	3c01      	subs	r4, #1
 80002b6:	f300 80ab 	bgt.w	8000410 <__aeabi_dmul+0x238>
 80002ba:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80002be:	bfde      	ittt	le
 80002c0:	2000      	movle	r0, #0
 80002c2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80002c6:	bd70      	pople	{r4, r5, r6, pc}
 80002c8:	f1c4 0400 	rsb	r4, r4, #0
 80002cc:	3c20      	subs	r4, #32
 80002ce:	da35      	bge.n	800033c <__aeabi_dmul+0x164>
 80002d0:	340c      	adds	r4, #12
 80002d2:	dc1b      	bgt.n	800030c <__aeabi_dmul+0x134>
 80002d4:	f104 0414 	add.w	r4, r4, #20
 80002d8:	f1c4 0520 	rsb	r5, r4, #32
 80002dc:	fa00 f305 	lsl.w	r3, r0, r5
 80002e0:	fa20 f004 	lsr.w	r0, r0, r4
 80002e4:	fa01 f205 	lsl.w	r2, r1, r5
 80002e8:	ea40 0002 	orr.w	r0, r0, r2
 80002ec:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 80002f0:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80002f4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80002f8:	fa21 f604 	lsr.w	r6, r1, r4
 80002fc:	eb42 0106 	adc.w	r1, r2, r6
 8000300:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000304:	bf08      	it	eq
 8000306:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800030a:	bd70      	pop	{r4, r5, r6, pc}
 800030c:	f1c4 040c 	rsb	r4, r4, #12
 8000310:	f1c4 0520 	rsb	r5, r4, #32
 8000314:	fa00 f304 	lsl.w	r3, r0, r4
 8000318:	fa20 f005 	lsr.w	r0, r0, r5
 800031c:	fa01 f204 	lsl.w	r2, r1, r4
 8000320:	ea40 0002 	orr.w	r0, r0, r2
 8000324:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000328:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800032c:	f141 0100 	adc.w	r1, r1, #0
 8000330:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000334:	bf08      	it	eq
 8000336:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800033a:	bd70      	pop	{r4, r5, r6, pc}
 800033c:	f1c4 0520 	rsb	r5, r4, #32
 8000340:	fa00 f205 	lsl.w	r2, r0, r5
 8000344:	ea4e 0e02 	orr.w	lr, lr, r2
 8000348:	fa20 f304 	lsr.w	r3, r0, r4
 800034c:	fa01 f205 	lsl.w	r2, r1, r5
 8000350:	ea43 0302 	orr.w	r3, r3, r2
 8000354:	fa21 f004 	lsr.w	r0, r1, r4
 8000358:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800035c:	fa21 f204 	lsr.w	r2, r1, r4
 8000360:	ea20 0002 	bic.w	r0, r0, r2
 8000364:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000368:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800036c:	bf08      	it	eq
 800036e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000372:	bd70      	pop	{r4, r5, r6, pc}
 8000374:	f094 0f00 	teq	r4, #0
 8000378:	d10f      	bne.n	800039a <__aeabi_dmul+0x1c2>
 800037a:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 800037e:	0040      	lsls	r0, r0, #1
 8000380:	eb41 0101 	adc.w	r1, r1, r1
 8000384:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000388:	bf08      	it	eq
 800038a:	3c01      	subeq	r4, #1
 800038c:	d0f7      	beq.n	800037e <__aeabi_dmul+0x1a6>
 800038e:	ea41 0106 	orr.w	r1, r1, r6
 8000392:	f095 0f00 	teq	r5, #0
 8000396:	bf18      	it	ne
 8000398:	4770      	bxne	lr
 800039a:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 800039e:	0052      	lsls	r2, r2, #1
 80003a0:	eb43 0303 	adc.w	r3, r3, r3
 80003a4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80003a8:	bf08      	it	eq
 80003aa:	3d01      	subeq	r5, #1
 80003ac:	d0f7      	beq.n	800039e <__aeabi_dmul+0x1c6>
 80003ae:	ea43 0306 	orr.w	r3, r3, r6
 80003b2:	4770      	bx	lr
 80003b4:	ea94 0f0c 	teq	r4, ip
 80003b8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80003bc:	bf18      	it	ne
 80003be:	ea95 0f0c 	teqne	r5, ip
 80003c2:	d00c      	beq.n	80003de <__aeabi_dmul+0x206>
 80003c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80003c8:	bf18      	it	ne
 80003ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80003ce:	d1d1      	bne.n	8000374 <__aeabi_dmul+0x19c>
 80003d0:	ea81 0103 	eor.w	r1, r1, r3
 80003d4:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80003d8:	f04f 0000 	mov.w	r0, #0
 80003dc:	bd70      	pop	{r4, r5, r6, pc}
 80003de:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80003e2:	bf06      	itte	eq
 80003e4:	4610      	moveq	r0, r2
 80003e6:	4619      	moveq	r1, r3
 80003e8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80003ec:	d019      	beq.n	8000422 <__aeabi_dmul+0x24a>
 80003ee:	ea94 0f0c 	teq	r4, ip
 80003f2:	d102      	bne.n	80003fa <__aeabi_dmul+0x222>
 80003f4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80003f8:	d113      	bne.n	8000422 <__aeabi_dmul+0x24a>
 80003fa:	ea95 0f0c 	teq	r5, ip
 80003fe:	d105      	bne.n	800040c <__aeabi_dmul+0x234>
 8000400:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000404:	bf1c      	itt	ne
 8000406:	4610      	movne	r0, r2
 8000408:	4619      	movne	r1, r3
 800040a:	d10a      	bne.n	8000422 <__aeabi_dmul+0x24a>
 800040c:	ea81 0103 	eor.w	r1, r1, r3
 8000410:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000414:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000418:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800041c:	f04f 0000 	mov.w	r0, #0
 8000420:	bd70      	pop	{r4, r5, r6, pc}
 8000422:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000426:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 800042a:	bd70      	pop	{r4, r5, r6, pc}

0800042c <__aeabi_drsub>:
 800042c:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000430:	e002      	b.n	8000438 <__adddf3>
 8000432:	bf00      	nop

08000434 <__aeabi_dsub>:
 8000434:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

08000438 <__adddf3>:
 8000438:	b530      	push	{r4, r5, lr}
 800043a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800043e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000442:	ea94 0f05 	teq	r4, r5
 8000446:	bf08      	it	eq
 8000448:	ea90 0f02 	teqeq	r0, r2
 800044c:	bf1f      	itttt	ne
 800044e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000452:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000456:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800045a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800045e:	f000 80e2 	beq.w	8000626 <__adddf3+0x1ee>
 8000462:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000466:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800046a:	bfb8      	it	lt
 800046c:	426d      	neglt	r5, r5
 800046e:	dd0c      	ble.n	800048a <__adddf3+0x52>
 8000470:	442c      	add	r4, r5
 8000472:	ea80 0202 	eor.w	r2, r0, r2
 8000476:	ea81 0303 	eor.w	r3, r1, r3
 800047a:	ea82 0000 	eor.w	r0, r2, r0
 800047e:	ea83 0101 	eor.w	r1, r3, r1
 8000482:	ea80 0202 	eor.w	r2, r0, r2
 8000486:	ea81 0303 	eor.w	r3, r1, r3
 800048a:	2d36      	cmp	r5, #54	@ 0x36
 800048c:	bf88      	it	hi
 800048e:	bd30      	pophi	{r4, r5, pc}
 8000490:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000494:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000498:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 800049c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80004a0:	d002      	beq.n	80004a8 <__adddf3+0x70>
 80004a2:	4240      	negs	r0, r0
 80004a4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80004a8:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80004ac:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80004b0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80004b4:	d002      	beq.n	80004bc <__adddf3+0x84>
 80004b6:	4252      	negs	r2, r2
 80004b8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80004bc:	ea94 0f05 	teq	r4, r5
 80004c0:	f000 80a7 	beq.w	8000612 <__adddf3+0x1da>
 80004c4:	f1a4 0401 	sub.w	r4, r4, #1
 80004c8:	f1d5 0e20 	rsbs	lr, r5, #32
 80004cc:	db0d      	blt.n	80004ea <__adddf3+0xb2>
 80004ce:	fa02 fc0e 	lsl.w	ip, r2, lr
 80004d2:	fa22 f205 	lsr.w	r2, r2, r5
 80004d6:	1880      	adds	r0, r0, r2
 80004d8:	f141 0100 	adc.w	r1, r1, #0
 80004dc:	fa03 f20e 	lsl.w	r2, r3, lr
 80004e0:	1880      	adds	r0, r0, r2
 80004e2:	fa43 f305 	asr.w	r3, r3, r5
 80004e6:	4159      	adcs	r1, r3
 80004e8:	e00e      	b.n	8000508 <__adddf3+0xd0>
 80004ea:	f1a5 0520 	sub.w	r5, r5, #32
 80004ee:	f10e 0e20 	add.w	lr, lr, #32
 80004f2:	2a01      	cmp	r2, #1
 80004f4:	fa03 fc0e 	lsl.w	ip, r3, lr
 80004f8:	bf28      	it	cs
 80004fa:	f04c 0c02 	orrcs.w	ip, ip, #2
 80004fe:	fa43 f305 	asr.w	r3, r3, r5
 8000502:	18c0      	adds	r0, r0, r3
 8000504:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000508:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 800050c:	d507      	bpl.n	800051e <__adddf3+0xe6>
 800050e:	f04f 0e00 	mov.w	lr, #0
 8000512:	f1dc 0c00 	rsbs	ip, ip, #0
 8000516:	eb7e 0000 	sbcs.w	r0, lr, r0
 800051a:	eb6e 0101 	sbc.w	r1, lr, r1
 800051e:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000522:	d31b      	bcc.n	800055c <__adddf3+0x124>
 8000524:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8000528:	d30c      	bcc.n	8000544 <__adddf3+0x10c>
 800052a:	0849      	lsrs	r1, r1, #1
 800052c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000530:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000534:	f104 0401 	add.w	r4, r4, #1
 8000538:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800053c:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8000540:	f080 809a 	bcs.w	8000678 <__adddf3+0x240>
 8000544:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 8000548:	bf08      	it	eq
 800054a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800054e:	f150 0000 	adcs.w	r0, r0, #0
 8000552:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000556:	ea41 0105 	orr.w	r1, r1, r5
 800055a:	bd30      	pop	{r4, r5, pc}
 800055c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000560:	4140      	adcs	r0, r0
 8000562:	eb41 0101 	adc.w	r1, r1, r1
 8000566:	3c01      	subs	r4, #1
 8000568:	bf28      	it	cs
 800056a:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800056e:	d2e9      	bcs.n	8000544 <__adddf3+0x10c>
 8000570:	f091 0f00 	teq	r1, #0
 8000574:	bf04      	itt	eq
 8000576:	4601      	moveq	r1, r0
 8000578:	2000      	moveq	r0, #0
 800057a:	fab1 f381 	clz	r3, r1
 800057e:	bf08      	it	eq
 8000580:	3320      	addeq	r3, #32
 8000582:	f1a3 030b 	sub.w	r3, r3, #11
 8000586:	f1b3 0220 	subs.w	r2, r3, #32
 800058a:	da0c      	bge.n	80005a6 <__adddf3+0x16e>
 800058c:	320c      	adds	r2, #12
 800058e:	dd08      	ble.n	80005a2 <__adddf3+0x16a>
 8000590:	f102 0c14 	add.w	ip, r2, #20
 8000594:	f1c2 020c 	rsb	r2, r2, #12
 8000598:	fa01 f00c 	lsl.w	r0, r1, ip
 800059c:	fa21 f102 	lsr.w	r1, r1, r2
 80005a0:	e00c      	b.n	80005bc <__adddf3+0x184>
 80005a2:	f102 0214 	add.w	r2, r2, #20
 80005a6:	bfd8      	it	le
 80005a8:	f1c2 0c20 	rsble	ip, r2, #32
 80005ac:	fa01 f102 	lsl.w	r1, r1, r2
 80005b0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80005b4:	bfdc      	itt	le
 80005b6:	ea41 010c 	orrle.w	r1, r1, ip
 80005ba:	4090      	lslle	r0, r2
 80005bc:	1ae4      	subs	r4, r4, r3
 80005be:	bfa2      	ittt	ge
 80005c0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80005c4:	4329      	orrge	r1, r5
 80005c6:	bd30      	popge	{r4, r5, pc}
 80005c8:	ea6f 0404 	mvn.w	r4, r4
 80005cc:	3c1f      	subs	r4, #31
 80005ce:	da1c      	bge.n	800060a <__adddf3+0x1d2>
 80005d0:	340c      	adds	r4, #12
 80005d2:	dc0e      	bgt.n	80005f2 <__adddf3+0x1ba>
 80005d4:	f104 0414 	add.w	r4, r4, #20
 80005d8:	f1c4 0220 	rsb	r2, r4, #32
 80005dc:	fa20 f004 	lsr.w	r0, r0, r4
 80005e0:	fa01 f302 	lsl.w	r3, r1, r2
 80005e4:	ea40 0003 	orr.w	r0, r0, r3
 80005e8:	fa21 f304 	lsr.w	r3, r1, r4
 80005ec:	ea45 0103 	orr.w	r1, r5, r3
 80005f0:	bd30      	pop	{r4, r5, pc}
 80005f2:	f1c4 040c 	rsb	r4, r4, #12
 80005f6:	f1c4 0220 	rsb	r2, r4, #32
 80005fa:	fa20 f002 	lsr.w	r0, r0, r2
 80005fe:	fa01 f304 	lsl.w	r3, r1, r4
 8000602:	ea40 0003 	orr.w	r0, r0, r3
 8000606:	4629      	mov	r1, r5
 8000608:	bd30      	pop	{r4, r5, pc}
 800060a:	fa21 f004 	lsr.w	r0, r1, r4
 800060e:	4629      	mov	r1, r5
 8000610:	bd30      	pop	{r4, r5, pc}
 8000612:	f094 0f00 	teq	r4, #0
 8000616:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800061a:	bf06      	itte	eq
 800061c:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000620:	3401      	addeq	r4, #1
 8000622:	3d01      	subne	r5, #1
 8000624:	e74e      	b.n	80004c4 <__adddf3+0x8c>
 8000626:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800062a:	bf18      	it	ne
 800062c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000630:	d029      	beq.n	8000686 <__adddf3+0x24e>
 8000632:	ea94 0f05 	teq	r4, r5
 8000636:	bf08      	it	eq
 8000638:	ea90 0f02 	teqeq	r0, r2
 800063c:	d005      	beq.n	800064a <__adddf3+0x212>
 800063e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000642:	bf04      	itt	eq
 8000644:	4619      	moveq	r1, r3
 8000646:	4610      	moveq	r0, r2
 8000648:	bd30      	pop	{r4, r5, pc}
 800064a:	ea91 0f03 	teq	r1, r3
 800064e:	bf1e      	ittt	ne
 8000650:	2100      	movne	r1, #0
 8000652:	2000      	movne	r0, #0
 8000654:	bd30      	popne	{r4, r5, pc}
 8000656:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800065a:	d105      	bne.n	8000668 <__adddf3+0x230>
 800065c:	0040      	lsls	r0, r0, #1
 800065e:	4149      	adcs	r1, r1
 8000660:	bf28      	it	cs
 8000662:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000666:	bd30      	pop	{r4, r5, pc}
 8000668:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 800066c:	bf3c      	itt	cc
 800066e:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 8000672:	bd30      	popcc	{r4, r5, pc}
 8000674:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000678:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 800067c:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000680:	f04f 0000 	mov.w	r0, #0
 8000684:	bd30      	pop	{r4, r5, pc}
 8000686:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800068a:	bf1a      	itte	ne
 800068c:	4619      	movne	r1, r3
 800068e:	4610      	movne	r0, r2
 8000690:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000694:	bf1c      	itt	ne
 8000696:	460b      	movne	r3, r1
 8000698:	4602      	movne	r2, r0
 800069a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800069e:	bf06      	itte	eq
 80006a0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80006a4:	ea91 0f03 	teqeq	r1, r3
 80006a8:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80006ac:	bd30      	pop	{r4, r5, pc}
 80006ae:	bf00      	nop

080006b0 <__aeabi_ui2d>:
 80006b0:	f090 0f00 	teq	r0, #0
 80006b4:	bf04      	itt	eq
 80006b6:	2100      	moveq	r1, #0
 80006b8:	4770      	bxeq	lr
 80006ba:	b530      	push	{r4, r5, lr}
 80006bc:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80006c0:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80006c4:	f04f 0500 	mov.w	r5, #0
 80006c8:	f04f 0100 	mov.w	r1, #0
 80006cc:	e750      	b.n	8000570 <__adddf3+0x138>
 80006ce:	bf00      	nop

080006d0 <__aeabi_i2d>:
 80006d0:	f090 0f00 	teq	r0, #0
 80006d4:	bf04      	itt	eq
 80006d6:	2100      	moveq	r1, #0
 80006d8:	4770      	bxeq	lr
 80006da:	b530      	push	{r4, r5, lr}
 80006dc:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80006e0:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80006e4:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 80006e8:	bf48      	it	mi
 80006ea:	4240      	negmi	r0, r0
 80006ec:	f04f 0100 	mov.w	r1, #0
 80006f0:	e73e      	b.n	8000570 <__adddf3+0x138>
 80006f2:	bf00      	nop

080006f4 <__aeabi_f2d>:
 80006f4:	0042      	lsls	r2, r0, #1
 80006f6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80006fa:	ea4f 0131 	mov.w	r1, r1, rrx
 80006fe:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000702:	bf1f      	itttt	ne
 8000704:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 8000708:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 800070c:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000710:	4770      	bxne	lr
 8000712:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 8000716:	bf08      	it	eq
 8000718:	4770      	bxeq	lr
 800071a:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 800071e:	bf04      	itt	eq
 8000720:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000724:	4770      	bxeq	lr
 8000726:	b530      	push	{r4, r5, lr}
 8000728:	f44f 7460 	mov.w	r4, #896	@ 0x380
 800072c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000730:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000734:	e71c      	b.n	8000570 <__adddf3+0x138>
 8000736:	bf00      	nop

08000738 <__aeabi_ul2d>:
 8000738:	ea50 0201 	orrs.w	r2, r0, r1
 800073c:	bf08      	it	eq
 800073e:	4770      	bxeq	lr
 8000740:	b530      	push	{r4, r5, lr}
 8000742:	f04f 0500 	mov.w	r5, #0
 8000746:	e00a      	b.n	800075e <__aeabi_l2d+0x16>

08000748 <__aeabi_l2d>:
 8000748:	ea50 0201 	orrs.w	r2, r0, r1
 800074c:	bf08      	it	eq
 800074e:	4770      	bxeq	lr
 8000750:	b530      	push	{r4, r5, lr}
 8000752:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000756:	d502      	bpl.n	800075e <__aeabi_l2d+0x16>
 8000758:	4240      	negs	r0, r0
 800075a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800075e:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000762:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000766:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800076a:	f43f aed8 	beq.w	800051e <__adddf3+0xe6>
 800076e:	f04f 0203 	mov.w	r2, #3
 8000772:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000776:	bf18      	it	ne
 8000778:	3203      	addne	r2, #3
 800077a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800077e:	bf18      	it	ne
 8000780:	3203      	addne	r2, #3
 8000782:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000786:	f1c2 0320 	rsb	r3, r2, #32
 800078a:	fa00 fc03 	lsl.w	ip, r0, r3
 800078e:	fa20 f002 	lsr.w	r0, r0, r2
 8000792:	fa01 fe03 	lsl.w	lr, r1, r3
 8000796:	ea40 000e 	orr.w	r0, r0, lr
 800079a:	fa21 f102 	lsr.w	r1, r1, r2
 800079e:	4414      	add	r4, r2
 80007a0:	e6bd      	b.n	800051e <__adddf3+0xe6>
 80007a2:	bf00      	nop

080007a4 <__aeabi_d2f>:
 80007a4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80007a8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 80007ac:	bf24      	itt	cs
 80007ae:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 80007b2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 80007b6:	d90d      	bls.n	80007d4 <__aeabi_d2f+0x30>
 80007b8:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 80007bc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80007c0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80007c4:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 80007c8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80007cc:	bf08      	it	eq
 80007ce:	f020 0001 	biceq.w	r0, r0, #1
 80007d2:	4770      	bx	lr
 80007d4:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 80007d8:	d121      	bne.n	800081e <__aeabi_d2f+0x7a>
 80007da:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 80007de:	bfbc      	itt	lt
 80007e0:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 80007e4:	4770      	bxlt	lr
 80007e6:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80007ea:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80007ee:	f1c2 0218 	rsb	r2, r2, #24
 80007f2:	f1c2 0c20 	rsb	ip, r2, #32
 80007f6:	fa10 f30c 	lsls.w	r3, r0, ip
 80007fa:	fa20 f002 	lsr.w	r0, r0, r2
 80007fe:	bf18      	it	ne
 8000800:	f040 0001 	orrne.w	r0, r0, #1
 8000804:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000808:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 800080c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000810:	ea40 000c 	orr.w	r0, r0, ip
 8000814:	fa23 f302 	lsr.w	r3, r3, r2
 8000818:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800081c:	e7cc      	b.n	80007b8 <__aeabi_d2f+0x14>
 800081e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000822:	d107      	bne.n	8000834 <__aeabi_d2f+0x90>
 8000824:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000828:	bf1e      	ittt	ne
 800082a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 800082e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000832:	4770      	bxne	lr
 8000834:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000838:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 800083c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000840:	4770      	bx	lr
 8000842:	bf00      	nop

08000844 <I2C1_init>:
 PB8--------SCL
 PB9--------SDA

 */

void I2C1_init(void){   // It takes no argument
 8000844:	b480      	push	{r7}
 8000846:	af00      	add	r7, sp, #0

	/* enable clock access to GPIOB */
	RCC->AHB1ENR |=GPIOBEN;
 8000848:	4b4b      	ldr	r3, [pc, #300]	@ (8000978 <I2C1_init+0x134>)
 800084a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800084c:	4a4a      	ldr	r2, [pc, #296]	@ (8000978 <I2C1_init+0x134>)
 800084e:	f043 0302 	orr.w	r3, r3, #2
 8000852:	6313      	str	r3, [r2, #48]	@ 0x30

	/* set PB8 and PB9 mode to alternate function */
	GPIOB->MODER &=~(1U<<16); //PB8 bit in the mode register is bit 16 and bit 17 and for alternate function mode the first bit has to be set to zero and the second bit has to be set to one
 8000854:	4b49      	ldr	r3, [pc, #292]	@ (800097c <I2C1_init+0x138>)
 8000856:	681b      	ldr	r3, [r3, #0]
 8000858:	4a48      	ldr	r2, [pc, #288]	@ (800097c <I2C1_init+0x138>)
 800085a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800085e:	6013      	str	r3, [r2, #0]
	GPIOB->MODER |=(1U<<17);
 8000860:	4b46      	ldr	r3, [pc, #280]	@ (800097c <I2C1_init+0x138>)
 8000862:	681b      	ldr	r3, [r3, #0]
 8000864:	4a45      	ldr	r2, [pc, #276]	@ (800097c <I2C1_init+0x138>)
 8000866:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800086a:	6013      	str	r3, [r2, #0]

	GPIOB->MODER &=~(1U<<18); //PB9 bit in the mode register is bit 18 and bit 19, bit 18 is the first bit, it has to be set to zero and bit 19 is set to one
 800086c:	4b43      	ldr	r3, [pc, #268]	@ (800097c <I2C1_init+0x138>)
 800086e:	681b      	ldr	r3, [r3, #0]
 8000870:	4a42      	ldr	r2, [pc, #264]	@ (800097c <I2C1_init+0x138>)
 8000872:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8000876:	6013      	str	r3, [r2, #0]
	GPIOB->MODER |=(1U<<19);
 8000878:	4b40      	ldr	r3, [pc, #256]	@ (800097c <I2C1_init+0x138>)
 800087a:	681b      	ldr	r3, [r3, #0]
 800087c:	4a3f      	ldr	r2, [pc, #252]	@ (800097c <I2C1_init+0x138>)
 800087e:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8000882:	6013      	str	r3, [r2, #0]

	/* set PB8 and PB9 output type to open drain - go to reference manual, go to GPIOx_OTYPER, it's the output type register. It's a 32-bit register. Upper 16 bits are reserved, lower 16 bits are used.It's telling us if
	 we want the output type, we can have two values, either push-pull or open drain. So if we want a particular one to be set to open drain, we need to set it to 1. So we're looking for pin 8 and pin 9. Therefore, we work with OT8
	 and OT9. We have to set these bits to 1 */
	GPIOB->OTYPER |=(1U<<8);
 8000884:	4b3d      	ldr	r3, [pc, #244]	@ (800097c <I2C1_init+0x138>)
 8000886:	685b      	ldr	r3, [r3, #4]
 8000888:	4a3c      	ldr	r2, [pc, #240]	@ (800097c <I2C1_init+0x138>)
 800088a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800088e:	6053      	str	r3, [r2, #4]
	GPIOB->OTYPER |=(1U<<9);
 8000890:	4b3a      	ldr	r3, [pc, #232]	@ (800097c <I2C1_init+0x138>)
 8000892:	685b      	ldr	r3, [r3, #4]
 8000894:	4a39      	ldr	r2, [pc, #228]	@ (800097c <I2C1_init+0x138>)
 8000896:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800089a:	6053      	str	r3, [r2, #4]

	/* Enable Pullup for PB8 and PB9 -go to reference manual, go to GPIOx_PUPDR,it's a 32-bit register, and all 32 bits are used.We can see there is separation after every two bits, meaning each pin requires two bits to configure its
	  pull-up, pull-down functionality. So because we are dealing with pins 8 and 9, we'll be interested in PUPDR8 and PUPDR9.PUPDR8 here occupies bits 17 and 16, according to truth table, it says if we want no pull-up or pull-down,
	  we set both bits to 0. If we want pull-up, we set the first bit to 1 and the second bit to 0. If we want pull-down, we set the first bit to 0 and the second bit to 1.Here we want pull-up because we want pull-up,
	  the first bit has to be set to 1 and the second bit to 0. So for PB8, the first bit is bit 16, the second bit is bit 17.And for PB9, the first bit is 18, the second bit is 19.     */
	GPIOB->PUPDR |=(1U<<16); // bit 16 set to 1 , bit 17 set to 0
 800089c:	4b37      	ldr	r3, [pc, #220]	@ (800097c <I2C1_init+0x138>)
 800089e:	68db      	ldr	r3, [r3, #12]
 80008a0:	4a36      	ldr	r2, [pc, #216]	@ (800097c <I2C1_init+0x138>)
 80008a2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80008a6:	60d3      	str	r3, [r2, #12]
	GPIOB->PUPDR &=~(1U<<17);
 80008a8:	4b34      	ldr	r3, [pc, #208]	@ (800097c <I2C1_init+0x138>)
 80008aa:	68db      	ldr	r3, [r3, #12]
 80008ac:	4a33      	ldr	r2, [pc, #204]	@ (800097c <I2C1_init+0x138>)
 80008ae:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 80008b2:	60d3      	str	r3, [r2, #12]

	GPIOB->PUPDR |=(1U<<18); // bit 18 set to 1 , bit 19 set to 0
 80008b4:	4b31      	ldr	r3, [pc, #196]	@ (800097c <I2C1_init+0x138>)
 80008b6:	68db      	ldr	r3, [r3, #12]
 80008b8:	4a30      	ldr	r2, [pc, #192]	@ (800097c <I2C1_init+0x138>)
 80008ba:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80008be:	60d3      	str	r3, [r2, #12]
	GPIOB->PUPDR &=~(1U<<19);
 80008c0:	4b2e      	ldr	r3, [pc, #184]	@ (800097c <I2C1_init+0x138>)
 80008c2:	68db      	ldr	r3, [r3, #12]
 80008c4:	4a2d      	ldr	r2, [pc, #180]	@ (800097c <I2C1_init+0x138>)
 80008c6:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 80008ca:	60d3      	str	r3, [r2, #12]
	 alternate. We see alternate function AFR. So we're looking for alternate function register high because we're dealing with pin 8 and 9. So these bits here, bit 0 to bit 3, are for pin 8. Bit 4 to bit 7 are for pin 9 because this
	 is AFRH9. So pin 9, AFRH8 for pin 8. So we said our I2C configuration is AF4. So the first bit has to be 0. The second bit has to be 0. Bit number 3, the third bit has to be 1, and then the fourth bit has to be 0. So we're going
	 to do that. So over here, after we set the pull-up and pull-down register, I'm going to say set alternate function, set PB8 and PB9 alternate function type to AF4. So we start with PB8. PB8, we said the first bit has to be 0, the
	 second bit 0, the third bit 1, and then the fourth bit, which is bit 3, has to be 0. Now we'll do the same for PB9. So I'll copy this. Then over here, PB9 starts from bit 4 to 7. The first bit has to be 0, the second bit has to be
	 0, the third bit has to be 1, and the final bit has to be 0.*/
	GPIOB->AFR[1] &=~(1U<<0);
 80008cc:	4b2b      	ldr	r3, [pc, #172]	@ (800097c <I2C1_init+0x138>)
 80008ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80008d0:	4a2a      	ldr	r2, [pc, #168]	@ (800097c <I2C1_init+0x138>)
 80008d2:	f023 0301 	bic.w	r3, r3, #1
 80008d6:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] &=~(1U<<1);
 80008d8:	4b28      	ldr	r3, [pc, #160]	@ (800097c <I2C1_init+0x138>)
 80008da:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80008dc:	4a27      	ldr	r2, [pc, #156]	@ (800097c <I2C1_init+0x138>)
 80008de:	f023 0302 	bic.w	r3, r3, #2
 80008e2:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] |=(1U<<2);
 80008e4:	4b25      	ldr	r3, [pc, #148]	@ (800097c <I2C1_init+0x138>)
 80008e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80008e8:	4a24      	ldr	r2, [pc, #144]	@ (800097c <I2C1_init+0x138>)
 80008ea:	f043 0304 	orr.w	r3, r3, #4
 80008ee:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] &=~(1U<<3);
 80008f0:	4b22      	ldr	r3, [pc, #136]	@ (800097c <I2C1_init+0x138>)
 80008f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80008f4:	4a21      	ldr	r2, [pc, #132]	@ (800097c <I2C1_init+0x138>)
 80008f6:	f023 0308 	bic.w	r3, r3, #8
 80008fa:	6253      	str	r3, [r2, #36]	@ 0x24

	GPIOB->AFR[1] &=~(1U<<4);
 80008fc:	4b1f      	ldr	r3, [pc, #124]	@ (800097c <I2C1_init+0x138>)
 80008fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000900:	4a1e      	ldr	r2, [pc, #120]	@ (800097c <I2C1_init+0x138>)
 8000902:	f023 0310 	bic.w	r3, r3, #16
 8000906:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] &=~(1U<<5);
 8000908:	4b1c      	ldr	r3, [pc, #112]	@ (800097c <I2C1_init+0x138>)
 800090a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800090c:	4a1b      	ldr	r2, [pc, #108]	@ (800097c <I2C1_init+0x138>)
 800090e:	f023 0320 	bic.w	r3, r3, #32
 8000912:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] |=(1U<<6);
 8000914:	4b19      	ldr	r3, [pc, #100]	@ (800097c <I2C1_init+0x138>)
 8000916:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000918:	4a18      	ldr	r2, [pc, #96]	@ (800097c <I2C1_init+0x138>)
 800091a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800091e:	6253      	str	r3, [r2, #36]	@ 0x24
	GPIOB->AFR[1] &=~(1U<<7);
 8000920:	4b16      	ldr	r3, [pc, #88]	@ (800097c <I2C1_init+0x138>)
 8000922:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000924:	4a15      	ldr	r2, [pc, #84]	@ (800097c <I2C1_init+0x138>)
 8000926:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800092a:	6253      	str	r3, [r2, #36]	@ 0x24


	/* enabling clock access to I2C1 - to enable the I2C clock, we simply access the APB1ENR and then we enable the I2C1 bit, which is bit 21. I2C1EN is the symbolic name. */
	RCC->APB1ENR |= I2C1EN;
 800092c:	4b12      	ldr	r3, [pc, #72]	@ (8000978 <I2C1_init+0x134>)
 800092e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000930:	4a11      	ldr	r2, [pc, #68]	@ (8000978 <I2C1_init+0x134>)
 8000932:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8000936:	6413      	str	r3, [r2, #64]	@ 0x40

	/*Enter reset mode - In order to configure the I2C we need to enter reset mode.Go to reference manual, go to I2C_CR1. Bit number 15 here is called the software reset, when it's 0, peripheral not under reset and
	  when it's 1, peripheral under reset. So we need to set bit 15 to 1.  */
	I2C1->CR1 |= (1U<<15);
 8000938:	4b11      	ldr	r3, [pc, #68]	@ (8000980 <I2C1_init+0x13c>)
 800093a:	681b      	ldr	r3, [r3, #0]
 800093c:	4a10      	ldr	r2, [pc, #64]	@ (8000980 <I2C1_init+0x13c>)
 800093e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8000942:	6013      	str	r3, [r2, #0]

	/*Come out of reset mode - It's just a requirement to enter reset and come out of reset. So to come out of reset, we set this same bit to 0. */
	I2C1->CR1 &=~(1U<<15);
 8000944:	4b0e      	ldr	r3, [pc, #56]	@ (8000980 <I2C1_init+0x13c>)
 8000946:	681b      	ldr	r3, [r3, #0]
 8000948:	4a0d      	ldr	r2, [pc, #52]	@ (8000980 <I2C1_init+0x13c>)
 800094a:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 800094e:	6013      	str	r3, [r2, #0]
	  value that corresponds to the particular clock frequency. So if our frequency is 1 Hz, we would have just put 1 at bit number 0 . If our frequency is 2 Hz,
	then we would put 1 at bit number 1 and then all other bits would be 0 because that's the binary value or the binary number for 2. So because our clock is 16 MHz, so all of it is in MHz. If our clock is
	1 MHz, we simply write 1 to bit 0, binary 1, which is setting bit 0 to 1 and all other bits to 0. If our clock is 2 MHz, we'll write 1 at bit position 1, which is binary 2 then all other bits will be set
	to 0.Our clock is 16 MHz.So what we're going to do is write 1 at bit position 4, such that we'll end up with 001000. and we know when we have 1 at the 5th position we get 2 raised to the power 4.
	If we want to convert it to decimal 2 raised to the power 4, which is 16. So we'll get 16 here. */
	I2C1->CR2 = (1U<<4);  //16MHz
 8000950:	4b0b      	ldr	r3, [pc, #44]	@ (8000980 <I2C1_init+0x13c>)
 8000952:	2210      	movs	r2, #16
 8000954:	605a      	str	r2, [r3, #4]
	 it to 80. This will give us I2C standard mode, which is 100 kilohertz. Create a symbolic name ,I2C_100KHZ. We're simply going to pass the decimal number 80 into our CCR register. Then, we're going to
	have another symbolic name known as the standard mode maximum rise time,SD_MODE_MAX_RISE_TIME, this value is 17. One way of computing these values is having Latin Cube MX computer for it you. There are various
	tools for computing the rise time and the value to input into the I2C registers. Various automatic tools for doing that. So, we're going to set this in the CCR register. And then, the rise time,
	we'll set it to 17. So, we'll use our standard mode value, I2C 100 kilohertz. We will place that into our CCR register.And then, there's another register known as TRISE. So, inside this register, we'll set
	the rise time. Go to I2C_TRISE, we're going to set the rise time from bit 1 to 5. We created a symbolic name for the maximum rise time for standard mode, which is 17. We're going to pass that into the TRISE register  */
	I2C1->CCR = I2C_100KHZ; //Set I2C to standard mode, 100khz clock
 8000956:	4b0a      	ldr	r3, [pc, #40]	@ (8000980 <I2C1_init+0x13c>)
 8000958:	2250      	movs	r2, #80	@ 0x50
 800095a:	61da      	str	r2, [r3, #28]
	I2C1->TRISE = SD_MODE_MAX_RISE_TIME;  //Set rise time
 800095c:	4b08      	ldr	r3, [pc, #32]	@ (8000980 <I2C1_init+0x13c>)
 800095e:	2211      	movs	r2, #17
 8000960:	621a      	str	r2, [r3, #32]
	I2C1->CR1 |= CR1_PE;  //Enable I2C1 module  - Go to the I2C control register, PE here is bit 0 is peripheral enable
 8000962:	4b07      	ldr	r3, [pc, #28]	@ (8000980 <I2C1_init+0x13c>)
 8000964:	681b      	ldr	r3, [r3, #0]
 8000966:	4a06      	ldr	r2, [pc, #24]	@ (8000980 <I2C1_init+0x13c>)
 8000968:	f043 0301 	orr.w	r3, r3, #1
 800096c:	6013      	str	r3, [r2, #0]

}
 800096e:	bf00      	nop
 8000970:	46bd      	mov	sp, r7
 8000972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000976:	4770      	bx	lr
 8000978:	40023800 	.word	0x40023800
 800097c:	40020400 	.word	0x40020400
 8000980:	40005400 	.word	0x40005400

08000984 <I2C1_byteRead>:
 have to write to the slave. So once all of this is set, we would transmit.Now we will read and transmit the slave address.Once this is done, we have to wait until the address flag is set.So just like we did before, we wait until
 the address flag is set. Once the address flag is set, we're going to disable the Acknowledge.In I2C_CR1, there is a flag for ACK, bit 10.Then we're going to clear the address flag again by reading status register 2 and storing it
 in tmp.Since we've just disabled the ACK, we've got to generate our stop condition. In I2C_CR1, there is a bit for stop,it's bit 9.Then we will wait until the RXNE flag is set,RXNE is in status register 1.In I2C_SR1 we want to wait
 for the receive buffer not empty flag. RXNE is bit 6. So receive buffer not empty, meaning there is something that we've received.So then we're going to take that something and store it in our variable which is called data which is
 our pointer variable (*data).  So we read the data register and store it. */
void I2C1_byteRead(char saddr, char maddr, char* data){
 8000984:	b480      	push	{r7}
 8000986:	b085      	sub	sp, #20
 8000988:	af00      	add	r7, sp, #0
 800098a:	4603      	mov	r3, r0
 800098c:	603a      	str	r2, [r7, #0]
 800098e:	71fb      	strb	r3, [r7, #7]
 8000990:	460b      	mov	r3, r1
 8000992:	71bb      	strb	r3, [r7, #6]

	volatile int tmp; //local variable tmp , to use it to read the register just to clear it
    /*wait until bus not busy - to check if the device is busy or to wait. What we want to do actually is wait for it to be free. So we'll wait until it is not busy.That is why we do not have the exclamation sign here.*/
	while(I2C1->SR2 & (SR2_BUSY)){}
 8000994:	bf00      	nop
 8000996:	4b34      	ldr	r3, [pc, #208]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000998:	699b      	ldr	r3, [r3, #24]
 800099a:	f003 0302 	and.w	r3, r3, #2
 800099e:	2b00      	cmp	r3, #0
 80009a0:	d1f9      	bne.n	8000996 <I2C1_byteRead+0x12>

	I2C1->CR1 |=CR1_START;  //generate start
 80009a2:	4b31      	ldr	r3, [pc, #196]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009a4:	681b      	ldr	r3, [r3, #0]
 80009a6:	4a30      	ldr	r2, [pc, #192]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009a8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80009ac:	6013      	str	r3, [r2, #0]

	/*we'll wait for SB to be set.We'll wait until the start bit is set.Look carefully to see the distinction here.We are saying while false because we have the exclamation sign here. So while the start bit is not set, we will get
	 stuck here. When it's set, we'll come out of this loop. */
	while(!(I2C1->SR1 & (SR1_SB))){}
 80009ae:	bf00      	nop
 80009b0:	4b2d      	ldr	r3, [pc, #180]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009b2:	695b      	ldr	r3, [r3, #20]
 80009b4:	f003 0301 	and.w	r3, r3, #1
 80009b8:	2b00      	cmp	r3, #0
 80009ba:	d0f9      	beq.n	80009b0 <I2C1_byteRead+0x2c>

	I2C1->DR = saddr<<1;  //Transmit slave address + write
 80009bc:	79fb      	ldrb	r3, [r7, #7]
 80009be:	4a2a      	ldr	r2, [pc, #168]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009c0:	005b      	lsls	r3, r3, #1
 80009c2:	6113      	str	r3, [r2, #16]

	/*Wait unitl address flag is set -  addr is the address flag in Status Register, I2C_SR1.*/
	while(!(I2C1->SR1 & (SR1_ADDR))){}
 80009c4:	bf00      	nop
 80009c6:	4b28      	ldr	r3, [pc, #160]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009c8:	695b      	ldr	r3, [r3, #20]
 80009ca:	f003 0302 	and.w	r3, r3, #2
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	d0f9      	beq.n	80009c6 <I2C1_byteRead+0x42>

	tmp= I2C1->SR2;     /*clear addr flag*/
 80009d2:	4b25      	ldr	r3, [pc, #148]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009d4:	699b      	ldr	r3, [r3, #24]
 80009d6:	60fb      	str	r3, [r7, #12]
	I2C1->DR = maddr;  /*send memory address*/
 80009d8:	4a23      	ldr	r2, [pc, #140]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009da:	79bb      	ldrb	r3, [r7, #6]
 80009dc:	6113      	str	r3, [r2, #16]
	while(!(I2C1->SR1 & (SR1_TXE))){}  /*wait until the transmitter is empty*/
 80009de:	bf00      	nop
 80009e0:	4b21      	ldr	r3, [pc, #132]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009e2:	695b      	ldr	r3, [r3, #20]
 80009e4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80009e8:	2b00      	cmp	r3, #0
 80009ea:	d0f9      	beq.n	80009e0 <I2C1_byteRead+0x5c>

	I2C1->CR1 |=CR1_START;  //generate restart
 80009ec:	4b1e      	ldr	r3, [pc, #120]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009ee:	681b      	ldr	r3, [r3, #0]
 80009f0:	4a1d      	ldr	r2, [pc, #116]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009f2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80009f6:	6013      	str	r3, [r2, #0]
	while(!(I2C1->SR1 & SR1_SB)){} //wait until start flag is set
 80009f8:	bf00      	nop
 80009fa:	4b1b      	ldr	r3, [pc, #108]	@ (8000a68 <I2C1_byteRead+0xe4>)
 80009fc:	695b      	ldr	r3, [r3, #20]
 80009fe:	f003 0301 	and.w	r3, r3, #1
 8000a02:	2b00      	cmp	r3, #0
 8000a04:	d0f9      	beq.n	80009fa <I2C1_byteRead+0x76>
	I2C1->DR = saddr<<1 |1 ;  //Transmit slave address + read
 8000a06:	79fb      	ldrb	r3, [r7, #7]
 8000a08:	005b      	lsls	r3, r3, #1
 8000a0a:	f043 0201 	orr.w	r2, r3, #1
 8000a0e:	4b16      	ldr	r3, [pc, #88]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a10:	611a      	str	r2, [r3, #16]
	while(!(I2C1->SR1 & (SR1_ADDR))){}  //Wait unitl addr flag is set
 8000a12:	bf00      	nop
 8000a14:	4b14      	ldr	r3, [pc, #80]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a16:	695b      	ldr	r3, [r3, #20]
 8000a18:	f003 0302 	and.w	r3, r3, #2
 8000a1c:	2b00      	cmp	r3, #0
 8000a1e:	d0f9      	beq.n	8000a14 <I2C1_byteRead+0x90>
	I2C1->CR1 &= ~CR1_ACK;  //disable acknowledge
 8000a20:	4b11      	ldr	r3, [pc, #68]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a22:	681b      	ldr	r3, [r3, #0]
 8000a24:	4a10      	ldr	r2, [pc, #64]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a26:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8000a2a:	6013      	str	r3, [r2, #0]
	tmp= I2C1->SR2;     /*clear addr flag*/
 8000a2c:	4b0e      	ldr	r3, [pc, #56]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a2e:	699b      	ldr	r3, [r3, #24]
 8000a30:	60fb      	str	r3, [r7, #12]
	I2C1->CR1 |=CR1_STOP;  //generate stop after data recieved
 8000a32:	4b0d      	ldr	r3, [pc, #52]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a34:	681b      	ldr	r3, [r3, #0]
 8000a36:	4a0c      	ldr	r2, [pc, #48]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a38:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8000a3c:	6013      	str	r3, [r2, #0]
	while(!(I2C1->SR1 & (SR1_RXNE))){}  //Wait unitl RXNE flag is set
 8000a3e:	bf00      	nop
 8000a40:	4b09      	ldr	r3, [pc, #36]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a42:	695b      	ldr	r3, [r3, #20]
 8000a44:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000a48:	2b00      	cmp	r3, #0
 8000a4a:	d0f9      	beq.n	8000a40 <I2C1_byteRead+0xbc>
	*data++= I2C1->DR;  //read data from DR
 8000a4c:	4b06      	ldr	r3, [pc, #24]	@ (8000a68 <I2C1_byteRead+0xe4>)
 8000a4e:	6919      	ldr	r1, [r3, #16]
 8000a50:	683b      	ldr	r3, [r7, #0]
 8000a52:	1c5a      	adds	r2, r3, #1
 8000a54:	603a      	str	r2, [r7, #0]
 8000a56:	b2ca      	uxtb	r2, r1
 8000a58:	701a      	strb	r2, [r3, #0]
}
 8000a5a:	bf00      	nop
 8000a5c:	3714      	adds	r7, #20
 8000a5e:	46bd      	mov	sp, r7
 8000a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a64:	4770      	bx	lr
 8000a66:	bf00      	nop
 8000a68:	40005400 	.word	0x40005400

08000a6c <I2C1_burstRead>:
 thing by setting the start bit in control register 1 to 1. So when we do that, we have to wait for the start bit to be set by inspecting the status register 1 start bit. So once that is done, we're going to transmit the slave address
 plus read. So just like we did earlier, transmit slave address with read and we wait until the address flag is set.Then we clear the address flag, we clear by reading SR2. Once we've cleared the address flag, we're going to enable
 acknowledge by setting the ACK bit to 1. Now we will say while the number of byte (n) passed an argument, while this is equal to 0, we want to do the number of things. (furthar comments are added above while loop for more clarity
 with the code itself.) */

void I2C1_burstRead(char saddr, char maddr,int n, char* data){
 8000a6c:	b480      	push	{r7}
 8000a6e:	b087      	sub	sp, #28
 8000a70:	af00      	add	r7, sp, #0
 8000a72:	60ba      	str	r2, [r7, #8]
 8000a74:	607b      	str	r3, [r7, #4]
 8000a76:	4603      	mov	r3, r0
 8000a78:	73fb      	strb	r3, [r7, #15]
 8000a7a:	460b      	mov	r3, r1
 8000a7c:	73bb      	strb	r3, [r7, #14]

	volatile int tmp;

	while(I2C1->SR2 & (SR2_BUSY)){}  //wait until bus not busy
 8000a7e:	bf00      	nop
 8000a80:	4b47      	ldr	r3, [pc, #284]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000a82:	699b      	ldr	r3, [r3, #24]
 8000a84:	f003 0302 	and.w	r3, r3, #2
 8000a88:	2b00      	cmp	r3, #0
 8000a8a:	d1f9      	bne.n	8000a80 <I2C1_burstRead+0x14>
	I2C1->CR1 |=CR1_START;  //generate start
 8000a8c:	4b44      	ldr	r3, [pc, #272]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000a8e:	681b      	ldr	r3, [r3, #0]
 8000a90:	4a43      	ldr	r2, [pc, #268]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000a92:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000a96:	6013      	str	r3, [r2, #0]
	while(!(I2C1->SR1 & (SR1_SB))){}  //wait until start flag is set
 8000a98:	bf00      	nop
 8000a9a:	4b41      	ldr	r3, [pc, #260]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000a9c:	695b      	ldr	r3, [r3, #20]
 8000a9e:	f003 0301 	and.w	r3, r3, #1
 8000aa2:	2b00      	cmp	r3, #0
 8000aa4:	d0f9      	beq.n	8000a9a <I2C1_burstRead+0x2e>
	I2C1->DR = saddr<<1;  //Transmit slave address + write
 8000aa6:	7bfb      	ldrb	r3, [r7, #15]
 8000aa8:	4a3d      	ldr	r2, [pc, #244]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000aaa:	005b      	lsls	r3, r3, #1
 8000aac:	6113      	str	r3, [r2, #16]
	while(!(I2C1->SR1 & (SR1_ADDR))){} //Wait unitl address flag is set
 8000aae:	bf00      	nop
 8000ab0:	4b3b      	ldr	r3, [pc, #236]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000ab2:	695b      	ldr	r3, [r3, #20]
 8000ab4:	f003 0302 	and.w	r3, r3, #2
 8000ab8:	2b00      	cmp	r3, #0
 8000aba:	d0f9      	beq.n	8000ab0 <I2C1_burstRead+0x44>
	tmp= I2C1->SR2;     //clear addr flag
 8000abc:	4b38      	ldr	r3, [pc, #224]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000abe:	699b      	ldr	r3, [r3, #24]
 8000ac0:	617b      	str	r3, [r7, #20]
	while(!(I2C1->SR1 & (SR1_TXE))){}  //wait until the transmitter is empty
 8000ac2:	bf00      	nop
 8000ac4:	4b36      	ldr	r3, [pc, #216]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000ac6:	695b      	ldr	r3, [r3, #20]
 8000ac8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000acc:	2b00      	cmp	r3, #0
 8000ace:	d0f9      	beq.n	8000ac4 <I2C1_burstRead+0x58>
	I2C1->DR = maddr;  //send memory address
 8000ad0:	4a33      	ldr	r2, [pc, #204]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000ad2:	7bbb      	ldrb	r3, [r7, #14]
 8000ad4:	6113      	str	r3, [r2, #16]
	while(!(I2C1->SR1 & (SR1_TXE))){}  //wait until the transmitter is empty
 8000ad6:	bf00      	nop
 8000ad8:	4b31      	ldr	r3, [pc, #196]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000ada:	695b      	ldr	r3, [r3, #20]
 8000adc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000ae0:	2b00      	cmp	r3, #0
 8000ae2:	d0f9      	beq.n	8000ad8 <I2C1_burstRead+0x6c>
	I2C1->CR1 |=CR1_START;  //generate restart.
 8000ae4:	4b2e      	ldr	r3, [pc, #184]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000ae6:	681b      	ldr	r3, [r3, #0]
 8000ae8:	4a2d      	ldr	r2, [pc, #180]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000aea:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000aee:	6013      	str	r3, [r2, #0]
	while(!(I2C1->SR1 & SR1_SB)){} //wait until start flag is set
 8000af0:	bf00      	nop
 8000af2:	4b2b      	ldr	r3, [pc, #172]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000af4:	695b      	ldr	r3, [r3, #20]
 8000af6:	f003 0301 	and.w	r3, r3, #1
 8000afa:	2b00      	cmp	r3, #0
 8000afc:	d0f9      	beq.n	8000af2 <I2C1_burstRead+0x86>
	I2C1->DR = saddr<<1 |1 ;  //Transmit slave address + read
 8000afe:	7bfb      	ldrb	r3, [r7, #15]
 8000b00:	005b      	lsls	r3, r3, #1
 8000b02:	f043 0201 	orr.w	r2, r3, #1
 8000b06:	4b26      	ldr	r3, [pc, #152]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b08:	611a      	str	r2, [r3, #16]
	while(!(I2C1->SR1 & (SR1_ADDR))){}  //Wait unitl addr flag is set
 8000b0a:	bf00      	nop
 8000b0c:	4b24      	ldr	r3, [pc, #144]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b0e:	695b      	ldr	r3, [r3, #20]
 8000b10:	f003 0302 	and.w	r3, r3, #2
 8000b14:	2b00      	cmp	r3, #0
 8000b16:	d0f9      	beq.n	8000b0c <I2C1_burstRead+0xa0>
	tmp= I2C1->SR2;     /*clear addr flag*/
 8000b18:	4b21      	ldr	r3, [pc, #132]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b1a:	699b      	ldr	r3, [r3, #24]
 8000b1c:	617b      	str	r3, [r7, #20]
	I2C1->CR1 |= CR1_ACK;  //enable acknowledge
 8000b1e:	4b20      	ldr	r3, [pc, #128]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b20:	681b      	ldr	r3, [r3, #0]
 8000b22:	4a1f      	ldr	r2, [pc, #124]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b24:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8000b28:	6013      	str	r3, [r2, #0]

	/* while n is greater than 0, we just put U here to indicate it's unsigned.We check if it's one byte left or if n is 1 or if the argument passed is 1 or if the n value here equals 1, the reason the n value be equal to 1
	 is we'll be decrementing the n value we would disable the ACK Knowledge and once we've done that, we'll generate a stop condition. Once we've generated a stop condition, we wait for the RXNE flag to be set. In other words,
	 we wait until the receive buffer is not empty and then we read the data from the data register.This is what we would execute when n equals 1.But if n is not equal to 1, we're going to implement an else condition here. All
	 we want to do is wait for the data to arrive by inspecting the RXNE. Once that is done, we're going to store it in our variable data. Then we're going to decrement n by saying n--. */
	while(n> 0U){
 8000b2a:	e02e      	b.n	8000b8a <I2C1_burstRead+0x11e>
		if(n == 1U) // if one byte
 8000b2c:	68bb      	ldr	r3, [r7, #8]
 8000b2e:	2b01      	cmp	r3, #1
 8000b30:	d11a      	bne.n	8000b68 <I2C1_burstRead+0xfc>
		{
			I2C1->CR1 &=~CR1_ACK; //disable acknowledge
 8000b32:	4b1b      	ldr	r3, [pc, #108]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b34:	681b      	ldr	r3, [r3, #0]
 8000b36:	4a1a      	ldr	r2, [pc, #104]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b38:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8000b3c:	6013      	str	r3, [r2, #0]
			I2C1->CR1 |= CR1_STOP; //generate stop
 8000b3e:	4b18      	ldr	r3, [pc, #96]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b40:	681b      	ldr	r3, [r3, #0]
 8000b42:	4a17      	ldr	r2, [pc, #92]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b44:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8000b48:	6013      	str	r3, [r2, #0]
			while(!(I2C1->SR1 & SR1_RXNE)){}  //wait for RXNE flag to set
 8000b4a:	bf00      	nop
 8000b4c:	4b14      	ldr	r3, [pc, #80]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b4e:	695b      	ldr	r3, [r3, #20]
 8000b50:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000b54:	2b00      	cmp	r3, #0
 8000b56:	d0f9      	beq.n	8000b4c <I2C1_burstRead+0xe0>
			*data++ = I2C1->DR;  //read data from DR
 8000b58:	4b11      	ldr	r3, [pc, #68]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b5a:	6919      	ldr	r1, [r3, #16]
 8000b5c:	687b      	ldr	r3, [r7, #4]
 8000b5e:	1c5a      	adds	r2, r3, #1
 8000b60:	607a      	str	r2, [r7, #4]
 8000b62:	b2ca      	uxtb	r2, r1
 8000b64:	701a      	strb	r2, [r3, #0]
			break;
 8000b66:	e014      	b.n	8000b92 <I2C1_burstRead+0x126>
		}
		else
		{
			while(!(I2C1->SR1 & SR1_RXNE)){}	//wait for RXNE flag to set
 8000b68:	bf00      	nop
 8000b6a:	4b0d      	ldr	r3, [pc, #52]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b6c:	695b      	ldr	r3, [r3, #20]
 8000b6e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000b72:	2b00      	cmp	r3, #0
 8000b74:	d0f9      	beq.n	8000b6a <I2C1_burstRead+0xfe>
			*data++ = I2C1->DR;  //read data from DR
 8000b76:	4b0a      	ldr	r3, [pc, #40]	@ (8000ba0 <I2C1_burstRead+0x134>)
 8000b78:	6919      	ldr	r1, [r3, #16]
 8000b7a:	687b      	ldr	r3, [r7, #4]
 8000b7c:	1c5a      	adds	r2, r3, #1
 8000b7e:	607a      	str	r2, [r7, #4]
 8000b80:	b2ca      	uxtb	r2, r1
 8000b82:	701a      	strb	r2, [r3, #0]
			n--;
 8000b84:	68bb      	ldr	r3, [r7, #8]
 8000b86:	3b01      	subs	r3, #1
 8000b88:	60bb      	str	r3, [r7, #8]
	while(n> 0U){
 8000b8a:	68bb      	ldr	r3, [r7, #8]
 8000b8c:	2b00      	cmp	r3, #0
 8000b8e:	d1cd      	bne.n	8000b2c <I2C1_burstRead+0xc0>
		}
	}
}
 8000b90:	bf00      	nop
 8000b92:	bf00      	nop
 8000b94:	371c      	adds	r7, #28
 8000b96:	46bd      	mov	sp, r7
 8000b98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b9c:	4770      	bx	lr
 8000b9e:	bf00      	nop
 8000ba0:	40005400 	.word	0x40005400

08000ba4 <I2C1_burstWrite>:
 and transmit the slave address plus write.Then,we'll wait until the address flag is set. And then we clear the address flag by reading status register 2. Then we wait until the data register is empty by reading the TXE flag in the
 status register 1. Then we send the memory address, because we want to read multiple bytes, we're going to use a for loop.This loop is going to transmit all the bytes. It's going to write all the bytes to the I2C.Once the loop is
 complete, we would have to wait until the BTF flag is set.Find  BTF flag in I2C_SR1. So this is called a byte transfer finished, it's bit number 2, set it to 1.Once that is done, we're going to generate a stop condition.

 */
void I2C1_burstWrite(char saddr, char maddr,int n, char* data){
 8000ba4:	b480      	push	{r7}
 8000ba6:	b087      	sub	sp, #28
 8000ba8:	af00      	add	r7, sp, #0
 8000baa:	60ba      	str	r2, [r7, #8]
 8000bac:	607b      	str	r3, [r7, #4]
 8000bae:	4603      	mov	r3, r0
 8000bb0:	73fb      	strb	r3, [r7, #15]
 8000bb2:	460b      	mov	r3, r1
 8000bb4:	73bb      	strb	r3, [r7, #14]

	volatile int tmp;

	while(I2C1->SR2 & (SR2_BUSY)){}  //wait until bus not busy
 8000bb6:	bf00      	nop
 8000bb8:	4b2a      	ldr	r3, [pc, #168]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bba:	699b      	ldr	r3, [r3, #24]
 8000bbc:	f003 0302 	and.w	r3, r3, #2
 8000bc0:	2b00      	cmp	r3, #0
 8000bc2:	d1f9      	bne.n	8000bb8 <I2C1_burstWrite+0x14>
	I2C1->CR1 |=CR1_START;  //generate start
 8000bc4:	4b27      	ldr	r3, [pc, #156]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bc6:	681b      	ldr	r3, [r3, #0]
 8000bc8:	4a26      	ldr	r2, [pc, #152]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bca:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000bce:	6013      	str	r3, [r2, #0]
	while(!(I2C1->SR1 & (SR1_SB))){}  //wait until start flag is set
 8000bd0:	bf00      	nop
 8000bd2:	4b24      	ldr	r3, [pc, #144]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bd4:	695b      	ldr	r3, [r3, #20]
 8000bd6:	f003 0301 	and.w	r3, r3, #1
 8000bda:	2b00      	cmp	r3, #0
 8000bdc:	d0f9      	beq.n	8000bd2 <I2C1_burstWrite+0x2e>
	I2C1->DR = saddr<<1;  //Transmit slave address + write
 8000bde:	7bfb      	ldrb	r3, [r7, #15]
 8000be0:	4a20      	ldr	r2, [pc, #128]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000be2:	005b      	lsls	r3, r3, #1
 8000be4:	6113      	str	r3, [r2, #16]
	while(!(I2C1->SR1 & (SR1_ADDR))){} //Wait unitl addr flag is set
 8000be6:	bf00      	nop
 8000be8:	4b1e      	ldr	r3, [pc, #120]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bea:	695b      	ldr	r3, [r3, #20]
 8000bec:	f003 0302 	and.w	r3, r3, #2
 8000bf0:	2b00      	cmp	r3, #0
 8000bf2:	d0f9      	beq.n	8000be8 <I2C1_burstWrite+0x44>
	tmp= I2C1->SR2;     //clear addr flag
 8000bf4:	4b1b      	ldr	r3, [pc, #108]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bf6:	699b      	ldr	r3, [r3, #24]
 8000bf8:	613b      	str	r3, [r7, #16]
	while(!(I2C1->SR1 & (SR1_TXE))){}  //wait until the transmitter is empty
 8000bfa:	bf00      	nop
 8000bfc:	4b19      	ldr	r3, [pc, #100]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000bfe:	695b      	ldr	r3, [r3, #20]
 8000c00:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000c04:	2b00      	cmp	r3, #0
 8000c06:	d0f9      	beq.n	8000bfc <I2C1_burstWrite+0x58>
	I2C1->DR = maddr;  //send memory address
 8000c08:	4a16      	ldr	r2, [pc, #88]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c0a:	7bbb      	ldrb	r3, [r7, #14]
 8000c0c:	6113      	str	r3, [r2, #16]

	for(int i=0; i <n; i++){
 8000c0e:	2300      	movs	r3, #0
 8000c10:	617b      	str	r3, [r7, #20]
 8000c12:	e00f      	b.n	8000c34 <I2C1_burstWrite+0x90>
		while(!(I2C1->SR1 & (SR1_TXE))){}  //wait until data register is empty,once it is empty, we transmit the next piece of data and then we increment
 8000c14:	bf00      	nop
 8000c16:	4b13      	ldr	r3, [pc, #76]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c18:	695b      	ldr	r3, [r3, #20]
 8000c1a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000c1e:	2b00      	cmp	r3, #0
 8000c20:	d0f9      	beq.n	8000c16 <I2C1_burstWrite+0x72>
		I2C1->DR = *data++;  //transmit memory address, here data is going to be an array that has what we want to write
 8000c22:	687b      	ldr	r3, [r7, #4]
 8000c24:	1c5a      	adds	r2, r3, #1
 8000c26:	607a      	str	r2, [r7, #4]
 8000c28:	781a      	ldrb	r2, [r3, #0]
 8000c2a:	4b0e      	ldr	r3, [pc, #56]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c2c:	611a      	str	r2, [r3, #16]
	for(int i=0; i <n; i++){
 8000c2e:	697b      	ldr	r3, [r7, #20]
 8000c30:	3301      	adds	r3, #1
 8000c32:	617b      	str	r3, [r7, #20]
 8000c34:	697a      	ldr	r2, [r7, #20]
 8000c36:	68bb      	ldr	r3, [r7, #8]
 8000c38:	429a      	cmp	r2, r3
 8000c3a:	dbeb      	blt.n	8000c14 <I2C1_burstWrite+0x70>
	}
	while(!(I2C1->SR1 & (SR1_BTF))){}  //wait until transfer finished
 8000c3c:	bf00      	nop
 8000c3e:	4b09      	ldr	r3, [pc, #36]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c40:	695b      	ldr	r3, [r3, #20]
 8000c42:	f003 0304 	and.w	r3, r3, #4
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d0f9      	beq.n	8000c3e <I2C1_burstWrite+0x9a>
	I2C1->CR1 |= CR1_STOP; //generate stop
 8000c4a:	4b06      	ldr	r3, [pc, #24]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c4c:	681b      	ldr	r3, [r3, #0]
 8000c4e:	4a05      	ldr	r2, [pc, #20]	@ (8000c64 <I2C1_burstWrite+0xc0>)
 8000c50:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8000c54:	6013      	str	r3, [r2, #0]

}
 8000c56:	bf00      	nop
 8000c58:	371c      	adds	r7, #28
 8000c5a:	46bd      	mov	sp, r7
 8000c5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c60:	4770      	bx	lr
 8000c62:	bf00      	nop
 8000c64:	40005400 	.word	0x40005400

08000c68 <adxl_read_address>:
/*This is a single function that reads registers.Here we're going to pass the register we want to read.What we can do here is take our I2C_byteRead function and we remember that our I2C_byteRead function, the first argument is the slave address, and we created a symbolic name for this slave address
 called device address. The second argument for our byte read function is the memory address and here that is what going to be passed as argument ,the register address and the third argument is it's a variable to store what we read so we're going to create this variable called data, it's going to be
  a global variable that will store what we read. */
char data;
uint8_t data_rec[6];
void adxl_read_address(uint8_t reg){
 8000c68:	b580      	push	{r7, lr}
 8000c6a:	b082      	sub	sp, #8
 8000c6c:	af00      	add	r7, sp, #0
 8000c6e:	4603      	mov	r3, r0
 8000c70:	71fb      	strb	r3, [r7, #7]
	I2C1_byteRead(DEVICE_ADDR, reg, &data);
 8000c72:	79fb      	ldrb	r3, [r7, #7]
 8000c74:	4a04      	ldr	r2, [pc, #16]	@ (8000c88 <adxl_read_address+0x20>)
 8000c76:	4619      	mov	r1, r3
 8000c78:	2053      	movs	r0, #83	@ 0x53
 8000c7a:	f7ff fe83 	bl	8000984 <I2C1_byteRead>
}
 8000c7e:	bf00      	nop
 8000c80:	3708      	adds	r7, #8
 8000c82:	46bd      	mov	sp, r7
 8000c84:	bd80      	pop	{r7, pc}
 8000c86:	bf00      	nop
 8000c88:	2000001c 	.word	0x2000001c

08000c8c <adxl_write>:

/*This is a function to write.Here, we call our burstWrite function because we have just a single write function unlike our read, we have byte read and burst read.We create a local buffer here called data. and we're going to take the value we want to write and place it into data[0] array and thenwe're
 going to call our burstWrite function.The first document is the slave address, second is the memory within the slave that we want to write, third argument is the number of bytes we want to write, and then the last argument is the buffer that contains the information we want to write to the slave.*/
void adxl_write(uint8_t reg, char value){
 8000c8c:	b580      	push	{r7, lr}
 8000c8e:	b084      	sub	sp, #16
 8000c90:	af00      	add	r7, sp, #0
 8000c92:	4603      	mov	r3, r0
 8000c94:	460a      	mov	r2, r1
 8000c96:	71fb      	strb	r3, [r7, #7]
 8000c98:	4613      	mov	r3, r2
 8000c9a:	71bb      	strb	r3, [r7, #6]
	char data[1];
	data[0]=value;
 8000c9c:	79bb      	ldrb	r3, [r7, #6]
 8000c9e:	733b      	strb	r3, [r7, #12]
	I2C1_burstWrite(DEVICE_ADDR, reg,1, data);
 8000ca0:	f107 030c 	add.w	r3, r7, #12
 8000ca4:	79f9      	ldrb	r1, [r7, #7]
 8000ca6:	2201      	movs	r2, #1
 8000ca8:	2053      	movs	r0, #83	@ 0x53
 8000caa:	f7ff ff7b 	bl	8000ba4 <I2C1_burstWrite>
}
 8000cae:	bf00      	nop
 8000cb0:	3710      	adds	r7, #16
 8000cb2:	46bd      	mov	sp, r7
 8000cb4:	bd80      	pop	{r7, pc}
	...

08000cb8 <adxl_read_values>:

/*This function will read multiple values.We use this function to read the data registers which are DATAX0 to DATAZ1, these are six, so we'll set the burst read length to six(refere axdl345 datasheet register map for more details).We create a variable to hold what we read, uint8_t data_rec[6]this is an
  array of size six.Once that is done,we call our first read function, we pass the device ID, the register, the length, and where we want to store what we read. Once we've done this, we can go ahead and initialize the device. */
void adxl_read_values(uint8_t reg){
 8000cb8:	b580      	push	{r7, lr}
 8000cba:	b082      	sub	sp, #8
 8000cbc:	af00      	add	r7, sp, #0
 8000cbe:	4603      	mov	r3, r0
 8000cc0:	71fb      	strb	r3, [r7, #7]
	I2C1_burstRead(DEVICE_ADDR, reg,6,(char *)data_rec);
 8000cc2:	79f9      	ldrb	r1, [r7, #7]
 8000cc4:	4b04      	ldr	r3, [pc, #16]	@ (8000cd8 <adxl_read_values+0x20>)
 8000cc6:	2206      	movs	r2, #6
 8000cc8:	2053      	movs	r0, #83	@ 0x53
 8000cca:	f7ff fecf 	bl	8000a6c <I2C1_burstRead>
}
 8000cce:	bf00      	nop
 8000cd0:	3708      	adds	r7, #8
 8000cd2:	46bd      	mov	sp, r7
 8000cd4:	bd80      	pop	{r7, pc}
 8000cd6:	bf00      	nop
 8000cd8:	20000020 	.word	0x20000020

08000cdc <adxl_init>:
/*This function is to initialize the device.First enable I2CC module.Then we're going to read the device ID, and when we read the device ID  successfully, this will indicate that our setup is done properly, or this will indicate that we are good.Read the device ID, DEVID , this should return, 0xE5
 according to the datasheet, then we know that everything is looking good. Once we've done this, we're going to set the data format range to plus or minus 4G.Then we're going to reset all bits, and we're going to set the power control measure bit. */
void adxl_init (void){
 8000cdc:	b580      	push	{r7, lr}
 8000cde:	af00      	add	r7, sp, #0

	I2C1_init();  //Enable I2C
 8000ce0:	f7ff fdb0 	bl	8000844 <I2C1_init>
	adxl_read_address(DEVID_R); //read the device ID, DEVID , this should return, 0xE5 according to the datasheet
 8000ce4:	2000      	movs	r0, #0
 8000ce6:	f7ff ffbf 	bl	8000c68 <adxl_read_address>
	adxl_write(DATA_FORMAT_R, FOUR_G); //set the data format range to +/- 4G
 8000cea:	2101      	movs	r1, #1
 8000cec:	2031      	movs	r0, #49	@ 0x31
 8000cee:	f7ff ffcd 	bl	8000c8c <adxl_write>
	adxl_write(POWER_CTL_R,RESET);  //reset all bits
 8000cf2:	2100      	movs	r1, #0
 8000cf4:	202d      	movs	r0, #45	@ 0x2d
 8000cf6:	f7ff ffc9 	bl	8000c8c <adxl_write>
	adxl_write(POWER_CTL_R,SET_MEASURE_B);  //configure power control measure bit
 8000cfa:	2108      	movs	r1, #8
 8000cfc:	202d      	movs	r0, #45	@ 0x2d
 8000cfe:	f7ff ffc5 	bl	8000c8c <adxl_write>

}
 8000d02:	bf00      	nop
 8000d04:	bd80      	pop	{r7, pc}
	...

08000d08 <main>:
 Remember we said we want to read all the values. So we want to read from X0 to Z1. We're going to be doing this repeatedly in the infinite loop and once that is done we need to combine X0 and X1 into a single x value. We have  created local
 variables  x,y,z and then xg,yg,zg. When we did our read values, the value read was stored in the buffer, There is a buffer that we created called data_rec .We create an external version because we need access to it's content.Here the first two values
 are the X0 and X1 values,we're going to combine them by shifting them to get a single value called X. We take index 0 and then perform an OR operation with index 1 shifted, this will give us x. We do the same to get y, Y0 and Y1 are located at index 2
 and index 3. So we do the same and then Z0, Z1 are located at index 4 and index 5.This will give us the x,y,z .Now to convert this to g there is a scale factor that we need to multiply this by and this is found in the data sheet.
 This is a constant called the 4g scale factor = 0.0078, we're going to multiply our x,y,z values with this value to get a unit in g.That's why we created this xg, yg, zg variable is to hold a unit in g. */
int main(void){
 8000d08:	b580      	push	{r7, lr}
 8000d0a:	af00      	add	r7, sp, #0

	adxl_init();
 8000d0c:	f7ff ffe6 	bl	8000cdc <adxl_init>
	while(1){
		adxl_read_values(DATA_START_ADDR);
 8000d10:	2032      	movs	r0, #50	@ 0x32
 8000d12:	f7ff ffd1 	bl	8000cb8 <adxl_read_values>
		x = ((data_rec[1]<<8)|data_rec[0]);
 8000d16:	4b32      	ldr	r3, [pc, #200]	@ (8000de0 <main+0xd8>)
 8000d18:	785b      	ldrb	r3, [r3, #1]
 8000d1a:	021b      	lsls	r3, r3, #8
 8000d1c:	b21a      	sxth	r2, r3
 8000d1e:	4b30      	ldr	r3, [pc, #192]	@ (8000de0 <main+0xd8>)
 8000d20:	781b      	ldrb	r3, [r3, #0]
 8000d22:	b21b      	sxth	r3, r3
 8000d24:	4313      	orrs	r3, r2
 8000d26:	b21a      	sxth	r2, r3
 8000d28:	4b2e      	ldr	r3, [pc, #184]	@ (8000de4 <main+0xdc>)
 8000d2a:	801a      	strh	r2, [r3, #0]
		y = ((data_rec[3]<<8)|data_rec[2]);
 8000d2c:	4b2c      	ldr	r3, [pc, #176]	@ (8000de0 <main+0xd8>)
 8000d2e:	78db      	ldrb	r3, [r3, #3]
 8000d30:	021b      	lsls	r3, r3, #8
 8000d32:	b21a      	sxth	r2, r3
 8000d34:	4b2a      	ldr	r3, [pc, #168]	@ (8000de0 <main+0xd8>)
 8000d36:	789b      	ldrb	r3, [r3, #2]
 8000d38:	b21b      	sxth	r3, r3
 8000d3a:	4313      	orrs	r3, r2
 8000d3c:	b21a      	sxth	r2, r3
 8000d3e:	4b2a      	ldr	r3, [pc, #168]	@ (8000de8 <main+0xe0>)
 8000d40:	801a      	strh	r2, [r3, #0]
		z = ((data_rec[5]<<8)|data_rec[4]);
 8000d42:	4b27      	ldr	r3, [pc, #156]	@ (8000de0 <main+0xd8>)
 8000d44:	795b      	ldrb	r3, [r3, #5]
 8000d46:	021b      	lsls	r3, r3, #8
 8000d48:	b21a      	sxth	r2, r3
 8000d4a:	4b25      	ldr	r3, [pc, #148]	@ (8000de0 <main+0xd8>)
 8000d4c:	791b      	ldrb	r3, [r3, #4]
 8000d4e:	b21b      	sxth	r3, r3
 8000d50:	4313      	orrs	r3, r2
 8000d52:	b21a      	sxth	r2, r3
 8000d54:	4b25      	ldr	r3, [pc, #148]	@ (8000dec <main+0xe4>)
 8000d56:	801a      	strh	r2, [r3, #0]
		xg = (x*0.0078);
 8000d58:	4b22      	ldr	r3, [pc, #136]	@ (8000de4 <main+0xdc>)
 8000d5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8000d5e:	4618      	mov	r0, r3
 8000d60:	f7ff fcb6 	bl	80006d0 <__aeabi_i2d>
 8000d64:	a31c      	add	r3, pc, #112	@ (adr r3, 8000dd8 <main+0xd0>)
 8000d66:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000d6a:	f7ff fa35 	bl	80001d8 <__aeabi_dmul>
 8000d6e:	4602      	mov	r2, r0
 8000d70:	460b      	mov	r3, r1
 8000d72:	4610      	mov	r0, r2
 8000d74:	4619      	mov	r1, r3
 8000d76:	f7ff fd15 	bl	80007a4 <__aeabi_d2f>
 8000d7a:	4603      	mov	r3, r0
 8000d7c:	4a1c      	ldr	r2, [pc, #112]	@ (8000df0 <main+0xe8>)
 8000d7e:	6013      	str	r3, [r2, #0]
		yg = (y*0.0078);
 8000d80:	4b19      	ldr	r3, [pc, #100]	@ (8000de8 <main+0xe0>)
 8000d82:	f9b3 3000 	ldrsh.w	r3, [r3]
 8000d86:	4618      	mov	r0, r3
 8000d88:	f7ff fca2 	bl	80006d0 <__aeabi_i2d>
 8000d8c:	a312      	add	r3, pc, #72	@ (adr r3, 8000dd8 <main+0xd0>)
 8000d8e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000d92:	f7ff fa21 	bl	80001d8 <__aeabi_dmul>
 8000d96:	4602      	mov	r2, r0
 8000d98:	460b      	mov	r3, r1
 8000d9a:	4610      	mov	r0, r2
 8000d9c:	4619      	mov	r1, r3
 8000d9e:	f7ff fd01 	bl	80007a4 <__aeabi_d2f>
 8000da2:	4603      	mov	r3, r0
 8000da4:	4a13      	ldr	r2, [pc, #76]	@ (8000df4 <main+0xec>)
 8000da6:	6013      	str	r3, [r2, #0]
		zg = (z*0.0078);
 8000da8:	4b10      	ldr	r3, [pc, #64]	@ (8000dec <main+0xe4>)
 8000daa:	f9b3 3000 	ldrsh.w	r3, [r3]
 8000dae:	4618      	mov	r0, r3
 8000db0:	f7ff fc8e 	bl	80006d0 <__aeabi_i2d>
 8000db4:	a308      	add	r3, pc, #32	@ (adr r3, 8000dd8 <main+0xd0>)
 8000db6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000dba:	f7ff fa0d 	bl	80001d8 <__aeabi_dmul>
 8000dbe:	4602      	mov	r2, r0
 8000dc0:	460b      	mov	r3, r1
 8000dc2:	4610      	mov	r0, r2
 8000dc4:	4619      	mov	r1, r3
 8000dc6:	f7ff fced 	bl	80007a4 <__aeabi_d2f>
 8000dca:	4603      	mov	r3, r0
 8000dcc:	4a0a      	ldr	r2, [pc, #40]	@ (8000df8 <main+0xf0>)
 8000dce:	6013      	str	r3, [r2, #0]
		adxl_read_values(DATA_START_ADDR);
 8000dd0:	bf00      	nop
 8000dd2:	e79d      	b.n	8000d10 <main+0x8>
 8000dd4:	f3af 8000 	nop.w
 8000dd8:	8e8a71de 	.word	0x8e8a71de
 8000ddc:	3f7ff2e4 	.word	0x3f7ff2e4
 8000de0:	20000020 	.word	0x20000020
 8000de4:	20000026 	.word	0x20000026
 8000de8:	20000028 	.word	0x20000028
 8000dec:	2000002a 	.word	0x2000002a
 8000df0:	2000002c 	.word	0x2000002c
 8000df4:	20000030 	.word	0x20000030
 8000df8:	20000034 	.word	0x20000034

08000dfc <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000dfc:	480d      	ldr	r0, [pc, #52]	@ (8000e34 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000dfe:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000e00:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000e04:	480c      	ldr	r0, [pc, #48]	@ (8000e38 <LoopForever+0x6>)
  ldr r1, =_edata
 8000e06:	490d      	ldr	r1, [pc, #52]	@ (8000e3c <LoopForever+0xa>)
  ldr r2, =_sidata
 8000e08:	4a0d      	ldr	r2, [pc, #52]	@ (8000e40 <LoopForever+0xe>)
  movs r3, #0
 8000e0a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000e0c:	e002      	b.n	8000e14 <LoopCopyDataInit>

08000e0e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000e0e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000e10:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000e12:	3304      	adds	r3, #4

08000e14 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000e14:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000e16:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000e18:	d3f9      	bcc.n	8000e0e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000e1a:	4a0a      	ldr	r2, [pc, #40]	@ (8000e44 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000e1c:	4c0a      	ldr	r4, [pc, #40]	@ (8000e48 <LoopForever+0x16>)
  movs r3, #0
 8000e1e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000e20:	e001      	b.n	8000e26 <LoopFillZerobss>

08000e22 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000e22:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000e24:	3204      	adds	r2, #4

08000e26 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000e26:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000e28:	d3fb      	bcc.n	8000e22 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8000e2a:	f000 f811 	bl	8000e50 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000e2e:	f7ff ff6b 	bl	8000d08 <main>

08000e32 <LoopForever>:

LoopForever:
  b LoopForever
 8000e32:	e7fe      	b.n	8000e32 <LoopForever>
  ldr   r0, =_estack
 8000e34:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8000e38:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000e3c:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 8000e40:	08000eb8 	.word	0x08000eb8
  ldr r2, =_sbss
 8000e44:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 8000e48:	20000038 	.word	0x20000038

08000e4c <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000e4c:	e7fe      	b.n	8000e4c <ADC_IRQHandler>
	...

08000e50 <__libc_init_array>:
 8000e50:	b570      	push	{r4, r5, r6, lr}
 8000e52:	4d0d      	ldr	r5, [pc, #52]	@ (8000e88 <__libc_init_array+0x38>)
 8000e54:	4c0d      	ldr	r4, [pc, #52]	@ (8000e8c <__libc_init_array+0x3c>)
 8000e56:	1b64      	subs	r4, r4, r5
 8000e58:	10a4      	asrs	r4, r4, #2
 8000e5a:	2600      	movs	r6, #0
 8000e5c:	42a6      	cmp	r6, r4
 8000e5e:	d109      	bne.n	8000e74 <__libc_init_array+0x24>
 8000e60:	4d0b      	ldr	r5, [pc, #44]	@ (8000e90 <__libc_init_array+0x40>)
 8000e62:	4c0c      	ldr	r4, [pc, #48]	@ (8000e94 <__libc_init_array+0x44>)
 8000e64:	f000 f818 	bl	8000e98 <_init>
 8000e68:	1b64      	subs	r4, r4, r5
 8000e6a:	10a4      	asrs	r4, r4, #2
 8000e6c:	2600      	movs	r6, #0
 8000e6e:	42a6      	cmp	r6, r4
 8000e70:	d105      	bne.n	8000e7e <__libc_init_array+0x2e>
 8000e72:	bd70      	pop	{r4, r5, r6, pc}
 8000e74:	f855 3b04 	ldr.w	r3, [r5], #4
 8000e78:	4798      	blx	r3
 8000e7a:	3601      	adds	r6, #1
 8000e7c:	e7ee      	b.n	8000e5c <__libc_init_array+0xc>
 8000e7e:	f855 3b04 	ldr.w	r3, [r5], #4
 8000e82:	4798      	blx	r3
 8000e84:	3601      	adds	r6, #1
 8000e86:	e7f2      	b.n	8000e6e <__libc_init_array+0x1e>
 8000e88:	08000eb0 	.word	0x08000eb0
 8000e8c:	08000eb0 	.word	0x08000eb0
 8000e90:	08000eb0 	.word	0x08000eb0
 8000e94:	08000eb4 	.word	0x08000eb4

08000e98 <_init>:
 8000e98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e9a:	bf00      	nop
 8000e9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000e9e:	bc08      	pop	{r3}
 8000ea0:	469e      	mov	lr, r3
 8000ea2:	4770      	bx	lr

08000ea4 <_fini>:
 8000ea4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ea6:	bf00      	nop
 8000ea8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000eaa:	bc08      	pop	{r3}
 8000eac:	469e      	mov	lr, r3
 8000eae:	4770      	bx	lr
