
20_uart_tx_DMA.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000003b0  08000198  08000198  00001198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000020  08000548  08000548  00001548  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08000568  08000568  00001570  2**0
                  CONTENTS
  4 .ARM          00000000  08000568  08000568  00001570  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000568  08000570  00001570  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000568  08000568  00001568  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0800056c  0800056c  0000156c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00001570  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000001c  20000000  08000570  00002000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000001c  08000570  0000201c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00001570  2**0
                  CONTENTS, READONLY
 12 .debug_info   00000ce5  00000000  00000000  000015a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000003b8  00000000  00000000  00002285  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000000c0  00000000  00000000  00002640  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00000085  00000000  00000000  00002700  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000e989  00000000  00000000  00002785  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00000fb6  00000000  00000000  0001110e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00053dea  00000000  00000000  000120c4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  00065eae  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000204  00000000  00000000  00065ef4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000041  00000000  00000000  000660f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000000 	.word	0x20000000
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08000530 	.word	0x08000530

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000004 	.word	0x20000004
 80001d4:	08000530 	.word	0x08000530

080001d8 <main>:
#define GPIOA_5     (1U<<5)
#define LED_PIN     GPIOA_5

static void dma_callback(void);
int main(void)
{
 80001d8:	b5b0      	push	{r4, r5, r7, lr}
 80001da:	b088      	sub	sp, #32
 80001dc:	af00      	add	r7, sp, #0
	char message[31] = "Hello from STM32 DMA transfer\n\r"; //this is our source buffer, we will be transferring this data , this string using DMA
 80001de:	4b14      	ldr	r3, [pc, #80]	@ (8000230 <main+0x58>)
 80001e0:	463c      	mov	r4, r7
 80001e2:	461d      	mov	r5, r3
 80001e4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80001e6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80001e8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80001ec:	c407      	stmia	r4!, {r0, r1, r2}
 80001ee:	8023      	strh	r3, [r4, #0]
 80001f0:	3402      	adds	r4, #2
 80001f2:	0c1b      	lsrs	r3, r3, #16
 80001f4:	7023      	strb	r3, [r4, #0]
	RCC->AHB1ENR |=GPIOAEN; //enable clock access to GPIOA
 80001f6:	4b0f      	ldr	r3, [pc, #60]	@ (8000234 <main+0x5c>)
 80001f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80001fa:	4a0e      	ldr	r2, [pc, #56]	@ (8000234 <main+0x5c>)
 80001fc:	f043 0301 	orr.w	r3, r3, #1
 8000200:	6313      	str	r3, [r2, #48]	@ 0x30

	//set PA5 as output pin
	GPIOA->MODER |= (1U<<10);
 8000202:	4b0d      	ldr	r3, [pc, #52]	@ (8000238 <main+0x60>)
 8000204:	681b      	ldr	r3, [r3, #0]
 8000206:	4a0c      	ldr	r2, [pc, #48]	@ (8000238 <main+0x60>)
 8000208:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800020c:	6013      	str	r3, [r2, #0]
	GPIOA->MODER &=~ (1U<<11);
 800020e:	4b0a      	ldr	r3, [pc, #40]	@ (8000238 <main+0x60>)
 8000210:	681b      	ldr	r3, [r3, #0]
 8000212:	4a09      	ldr	r2, [pc, #36]	@ (8000238 <main+0x60>)
 8000214:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8000218:	6013      	str	r3, [r2, #0]

    uart2_tx_init();
 800021a:	f000 f8c9 	bl	80003b0 <uart2_tx_init>

    /*source buffer here is going to be an array. Our destination is DMA data register, Our destination is the USART2 data register.The length of the source is 31. */
    dma1_stream6_init((uint32_t) message, (uint32_t)&USART2->DR, 31 );  //void dma1_stream6_init(uint32_t src, uint32_dst, uint32_t len);
 800021e:	463b      	mov	r3, r7
 8000220:	221f      	movs	r2, #31
 8000222:	4906      	ldr	r1, [pc, #24]	@ (800023c <main+0x64>)
 8000224:	4618      	mov	r0, r3
 8000226:	f000 f84d 	bl	80002c4 <dma1_stream6_init>

    while(1){}
 800022a:	bf00      	nop
 800022c:	e7fd      	b.n	800022a <main+0x52>
 800022e:	bf00      	nop
 8000230:	08000548 	.word	0x08000548
 8000234:	40023800 	.word	0x40023800
 8000238:	40020000 	.word	0x40020000
 800023c:	40004404 	.word	0x40004404

08000240 <dma_callback>:
}
// In our callback function, we want to read the USAT data register.
static void dma_callback(void)
{
 8000240:	b480      	push	{r7}
 8000242:	af00      	add	r7, sp, #0
	GPIOA->ODR |= LED_PIN;/*Turn ON the LED when the transfer is complete*/
 8000244:	4b05      	ldr	r3, [pc, #20]	@ (800025c <dma_callback+0x1c>)
 8000246:	695b      	ldr	r3, [r3, #20]
 8000248:	4a04      	ldr	r2, [pc, #16]	@ (800025c <dma_callback+0x1c>)
 800024a:	f043 0320 	orr.w	r3, r3, #32
 800024e:	6153      	str	r3, [r2, #20]
}
 8000250:	bf00      	nop
 8000252:	46bd      	mov	sp, r7
 8000254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000258:	4770      	bx	lr
 800025a:	bf00      	nop
 800025c:	40020000 	.word	0x40020000

08000260 <DMA1_Stream6_IRQHandler>:
 by checking if it is indeed the transfer complete interrupt that has occurred, if that's the case, then we want to run a particular piece of code.To do this, we need to check our DMA1 high status register and check for transfer complete bit.
 Search for DMA_HISR in reference manual.It's called high because it's for stream 4 and above. The low is for starting from stream 0 to 3.We are interested in transfer complete interrupt for stream 6, bit 21 is TCIF6, created a symbolic name HISR_TCIF6.
 Because we want to access this in our main function, we have put put this one in our uart.h file.Then we want to clear the flag. Remember, we clear the interrupt flag and then we can do something .To clear the flag, we need to go to a separate register.
 This is known as the HIFC register.In DMA_HIFCR , bit 21 is clear transfer complete interrupt flag, writing 1 to this bit clears the corresponding TCIFx flag in the DMA_HISR register */
void DMA1_Stream6_IRQHandler(void)
{
 8000260:	b580      	push	{r7, lr}
 8000262:	af00      	add	r7, sp, #0
	/*check for transfer complete - we do this by using if statement. Remember when we check, we use if,when we want to wait we use while.Here we want to read, so to read a bit, we perform an AND operation. */
	if(DMA1->HISR & HISR_TCIF6)
 8000264:	4b07      	ldr	r3, [pc, #28]	@ (8000284 <DMA1_Stream6_IRQHandler+0x24>)
 8000266:	685b      	ldr	r3, [r3, #4]
 8000268:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800026c:	2b00      	cmp	r3, #0
 800026e:	d005      	beq.n	800027c <DMA1_Stream6_IRQHandler+0x1c>
	{
		DMA1->HIFCR |=HIFCR_CTCIF6; /*clear flag*/
 8000270:	4b04      	ldr	r3, [pc, #16]	@ (8000284 <DMA1_Stream6_IRQHandler+0x24>)
 8000272:	68db      	ldr	r3, [r3, #12]
 8000274:	4a03      	ldr	r2, [pc, #12]	@ (8000284 <DMA1_Stream6_IRQHandler+0x24>)
 8000276:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800027a:	60d3      	str	r3, [r2, #12]
	}
	/*Do something.*/
	dma_callback();
 800027c:	f7ff ffe0 	bl	8000240 <dma_callback>
}
 8000280:	bf00      	nop
 8000282:	bd80      	pop	{r7, pc}
 8000284:	40026000 	.word	0x40026000

08000288 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000288:	b480      	push	{r7}
 800028a:	b083      	sub	sp, #12
 800028c:	af00      	add	r7, sp, #0
 800028e:	4603      	mov	r3, r0
 8000290:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8000292:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000296:	2b00      	cmp	r3, #0
 8000298:	db0b      	blt.n	80002b2 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800029a:	79fb      	ldrb	r3, [r7, #7]
 800029c:	f003 021f 	and.w	r2, r3, #31
 80002a0:	4907      	ldr	r1, [pc, #28]	@ (80002c0 <__NVIC_EnableIRQ+0x38>)
 80002a2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80002a6:	095b      	lsrs	r3, r3, #5
 80002a8:	2001      	movs	r0, #1
 80002aa:	fa00 f202 	lsl.w	r2, r0, r2
 80002ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 80002b2:	bf00      	nop
 80002b4:	370c      	adds	r7, #12
 80002b6:	46bd      	mov	sp, r7
 80002b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002bc:	4770      	bx	lr
 80002be:	bf00      	nop
 80002c0:	e000e100 	.word	0xe000e100

080002c4 <dma1_stream6_init>:
 We click DMA 1 request mapping. In table, DMA1 request mapping (STM32F411xC/E).The columns indicate the DMA streams. The rows indicate the channel .here in stream 6, we have USART2_TX.
 Stream 6, we're going to enable DMA 1 and channel 4 of stream 6 uses this feature.*/

/*This function here is going to take a number of arguments.We going to pass the source, the destination, and the length of the data we want to transfer */
void dma1_stream6_init(uint32_t src,uint32_t dst,uint32_t len)
{
 80002c4:	b580      	push	{r7, lr}
 80002c6:	b084      	sub	sp, #16
 80002c8:	af00      	add	r7, sp, #0
 80002ca:	60f8      	str	r0, [r7, #12]
 80002cc:	60b9      	str	r1, [r7, #8]
 80002ce:	607a      	str	r2, [r7, #4]
	/*enable clock access to DMA - If we go to our block diagram in the datasheet, we realize that the DMA module 1 is connected to the AHB1 bus.Go to reference manual and search AHB1ENR.
	 We find bit 21 is called DMA 1 enable. */
	RCC->AHB1ENR |=DMA1EN;
 80002d0:	4b33      	ldr	r3, [pc, #204]	@ (80003a0 <dma1_stream6_init+0xdc>)
 80002d2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80002d4:	4a32      	ldr	r2, [pc, #200]	@ (80003a0 <dma1_stream6_init+0xdc>)
 80002d6:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80002da:	6313      	str	r3, [r2, #48]	@ 0x30

	/*disable DMA1 and stream 6- To do this, we have to go to the configuration register of the particular stream.Go to reference manual and go to DMA section.Scroll down to DMA registers.It's called
	DMA_SxCR,here S stands for stream and x stands for the stream number.Bit number 0 over here is the EN, meaning enable bit,we need to disable, essentially set to 0 in order to disable the particular DMA stream.
	Created a symbolic name. The name of the register is configuration register, but the name of the structure for the DMA stream 6 is written as DMA1_nameofthestream and then we access the configuration register. */
	DMA1_Stream6->CR &=~DMA_CR_EN; //DMA1_Stream 6, this structure is exist in our .h file.
 80002dc:	4b31      	ldr	r3, [pc, #196]	@ (80003a4 <dma1_stream6_init+0xe0>)
 80002de:	681b      	ldr	r3, [r3, #0]
 80002e0:	4a30      	ldr	r2, [pc, #192]	@ (80003a4 <dma1_stream6_init+0xe0>)
 80002e2:	f023 0301 	bic.w	r3, r3, #1
 80002e6:	6013      	str	r3, [r2, #0]

	/*	Wait until DMA1 Stream6 is disabled*/
	while(DMA1_Stream6->CR &= DMA_CR_EN){}
 80002e8:	bf00      	nop
 80002ea:	4b2e      	ldr	r3, [pc, #184]	@ (80003a4 <dma1_stream6_init+0xe0>)
 80002ec:	681b      	ldr	r3, [r3, #0]
 80002ee:	4a2d      	ldr	r2, [pc, #180]	@ (80003a4 <dma1_stream6_init+0xe0>)
 80002f0:	f003 0301 	and.w	r3, r3, #1
 80002f4:	6013      	str	r3, [r2, #0]
 80002f6:	2b00      	cmp	r3, #0
 80002f8:	d1f7      	bne.n	80002ea <dma1_stream6_init+0x26>

	/*clear all the interrupted flags for stream6-go to the DMA1 HIFCR (High Interrupt Flag Clear Register) register. We're looking for stream 6. Let's read what the description says. It says when we see CTCIFx
	 this is stream x, clear transfer complete interrupt flag. So there are a number of interrupt flags for each stream. There is the transfer complete, there is the half transfer, meaning if the transfer is half
	 complete the interrupt can be generated.There is error interrupt. So we said we're going to clear all stream 6 interrupts. we want to clear all the interrupts for stream 6 we said.Bit 16, bit 18, bit 19, bit 20,
	 bit 21.We'll  clear all these bits.Writing 1 to these bits clears the corresponding flag in the register. */
	DMA1->HIFCR |=(1U<<16);
 80002fa:	4b2b      	ldr	r3, [pc, #172]	@ (80003a8 <dma1_stream6_init+0xe4>)
 80002fc:	68db      	ldr	r3, [r3, #12]
 80002fe:	4a2a      	ldr	r2, [pc, #168]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000300:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000304:	60d3      	str	r3, [r2, #12]
	DMA1->HIFCR |=(1U<<18);
 8000306:	4b28      	ldr	r3, [pc, #160]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000308:	68db      	ldr	r3, [r3, #12]
 800030a:	4a27      	ldr	r2, [pc, #156]	@ (80003a8 <dma1_stream6_init+0xe4>)
 800030c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8000310:	60d3      	str	r3, [r2, #12]
	DMA1->HIFCR |=(1U<<19);
 8000312:	4b25      	ldr	r3, [pc, #148]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000314:	68db      	ldr	r3, [r3, #12]
 8000316:	4a24      	ldr	r2, [pc, #144]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000318:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800031c:	60d3      	str	r3, [r2, #12]
	DMA1->HIFCR |=(1U<<20);
 800031e:	4b22      	ldr	r3, [pc, #136]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000320:	68db      	ldr	r3, [r3, #12]
 8000322:	4a21      	ldr	r2, [pc, #132]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000324:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000328:	60d3      	str	r3, [r2, #12]
	DMA1->HIFCR |=(1U<<21);
 800032a:	4b1f      	ldr	r3, [pc, #124]	@ (80003a8 <dma1_stream6_init+0xe4>)
 800032c:	68db      	ldr	r3, [r3, #12]
 800032e:	4a1e      	ldr	r2, [pc, #120]	@ (80003a8 <dma1_stream6_init+0xe4>)
 8000330:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8000334:	60d3      	str	r3, [r2, #12]

	/*set the destination buffer - go to the PAR register, and simply assign our destination to it.*/
	DMA1_Stream6->PAR = dst;
 8000336:	4a1b      	ldr	r2, [pc, #108]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000338:	68bb      	ldr	r3, [r7, #8]
 800033a:	6093      	str	r3, [r2, #8]

	/*set the source buffer - the source is the memory source. So we go to the M0AR register, and we can find this in DMA registers. This is where we put a peripheral address, PAR is the peripheral because we
	 want our destination to be the UART peripheral that's why we're setting our destination address at PAR, and then our source is going to be memory. */
	DMA1_Stream6->M0AR=src;
 800033c:	4a19      	ldr	r2, [pc, #100]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800033e:	68fb      	ldr	r3, [r7, #12]
 8000340:	60d3      	str	r3, [r2, #12]

	/*set the length = NDTR register here holds the length of the transfer*/
	DMA1_Stream6->NDTR =len;
 8000342:	4a18      	ldr	r2, [pc, #96]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000344:	687b      	ldr	r3, [r7, #4]
 8000346:	6053      	str	r3, [r2, #4]

	/*select Stream6 CH4 -  go to the DMA Stream configuration Register the same register that we analyzed earlier,DMA_SxCR.The channel select bit is CHSEL its bits 25,26,27.I f we want to select Channel 4, these are the values.
	 The first bit has to be 0,second bit has to be 0, third bit, which is bit 27, has to be set to 1. We have created a symbolic name.*/
	DMA1_Stream6->CR = CHSEL4;  // not using the OR operator because we want to clear the register
 8000348:	4b16      	ldr	r3, [pc, #88]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800034a:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 800034e:	601a      	str	r2, [r3, #0]

	/*Enable memory to increment-we have the option to see whether the memory should increment or not or whether the peripheral should increment, or whether both of them should increment.and we want the memory to increment,
	 because the data is stored in the buffer. When you access the first index of the buffer, you want to increment to the next index.we're going to access the same register to enable memory increment.Go to the configuration register
	 DMA_SxCR, we have MINC which stands for memory increment.Bit 10 is memory increment mode. */
	DMA1_Stream6->CR |= DMA_MEM_INC; //this time we will use OR operator here because we don't want to clean CHSEL4,we want to add this other parameter to what is already set in our stream 6 configuration register.
 8000350:	4b14      	ldr	r3, [pc, #80]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000352:	681b      	ldr	r3, [r3, #0]
 8000354:	4a13      	ldr	r2, [pc, #76]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000356:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800035a:	6013      	str	r3, [r2, #0]

	/*configure transfer direction - Whether the data is moving from memory to a peripheral, or from peripheral to a memory. In this case, the data will be moving from memory to a peripheral.And what this means is that the data
	 is stored in an array and we're going to take the content of this array and move it to the UART peripheral using DMA. So the direction here is memory to peripheral. Go to configuration register DMA_SxCR, bit 6,7, together we call it a
	 DIR, meaning direction.We want to set bit 6 to 1 and 7 to 0(which is by default ) for our Memory-to-peripheral.We have created a symbolic name.  */
	DMA1_Stream6->CR |= DMA_DIR_MEM_TO_PERIPH;
 800035c:	4b11      	ldr	r3, [pc, #68]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800035e:	681b      	ldr	r3, [r3, #0]
 8000360:	4a10      	ldr	r2, [pc, #64]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000362:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8000366:	6013      	str	r3, [r2, #0]

	/*enable DMA transfer complete interrupt - here, we're going to enable at least one interrupt. Remember, we cleared all of  interrupt flags.We're going to just make use of one.We're going to use the transfer complete interrupt,TCIE.
	which is bit 4. Whenever you see a bit name ending with IE, it means interrupt enable.Createdd a symbolic name to set bit 4 to 1.*/
	DMA1_Stream6->CR |= DMA_CR_TCIE;
 8000368:	4b0e      	ldr	r3, [pc, #56]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800036a:	681b      	ldr	r3, [r3, #0]
 800036c:	4a0d      	ldr	r2, [pc, #52]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800036e:	f043 0310 	orr.w	r3, r3, #16
 8000372:	6013      	str	r3, [r2, #0]
	/*enable direct mode, disable the FIFO mode - go to the FIFO control register in DMA Register section.We're going to write zero to this entire register because when we write zero it says FEIE interrupt disabled.
	 We disable FTH and FS to zero.We say we are enabling direct mode. So when we set DMDIS, direct mode disable to zero we'll get direct mode enabled as well. We'l lwrite zero to this register.
	And in effect we'll be disabling the FIFO and enabling the direct mode. */
	DMA1_Stream6->FCR =0;
 8000374:	4b0b      	ldr	r3, [pc, #44]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000376:	2200      	movs	r2, #0
 8000378:	615a      	str	r2, [r3, #20]

	/*enable DMA1 stream 6 - go to the DMA Configuration Register.Bit 0 here is EN. */
	DMA1_Stream6->CR |= DMA_CR_EN;
 800037a:	4b0a      	ldr	r3, [pc, #40]	@ (80003a4 <dma1_stream6_init+0xe0>)
 800037c:	681b      	ldr	r3, [r3, #0]
 800037e:	4a09      	ldr	r2, [pc, #36]	@ (80003a4 <dma1_stream6_init+0xe0>)
 8000380:	f043 0301 	orr.w	r3, r3, #1
 8000384:	6013      	str	r3, [r2, #0]

	/*enable UART2 transmitter DMA - We're going to enable UART Transmitter DMA over here. Go to UART module. This time UART Control Register 3 to connect it to the DMA. Search USART_CR3.Bit 7 here is DMAT, DMA Transmitter.*/
	USART2->CR3 |= UART_CR3_DMAT;
 8000386:	4b09      	ldr	r3, [pc, #36]	@ (80003ac <dma1_stream6_init+0xe8>)
 8000388:	695b      	ldr	r3, [r3, #20]
 800038a:	4a08      	ldr	r2, [pc, #32]	@ (80003ac <dma1_stream6_init+0xe8>)
 800038c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8000390:	6153      	str	r3, [r2, #20]

	/*DMA interrupt enable in NVIC - after the transfer is complete, we can decide to run a piece of code.We can run a piece of code in the middle of the transfer or when it's complete, we can say if the transfer
	 is half complete, run this piece of code. If it is one-third complete, run this other piece of code etc.We use NVIC interrupt IRQ and we use DMA1_Stream6_IRQn. That's the interrupt request number for DMA 1 stream 6. */
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);
 8000392:	2011      	movs	r0, #17
 8000394:	f7ff ff78 	bl	8000288 <__NVIC_EnableIRQ>
}
 8000398:	bf00      	nop
 800039a:	3710      	adds	r7, #16
 800039c:	46bd      	mov	sp, r7
 800039e:	bd80      	pop	{r7, pc}
 80003a0:	40023800 	.word	0x40023800
 80003a4:	400260a0 	.word	0x400260a0
 80003a8:	40026000 	.word	0x40026000
 80003ac:	40004400 	.word	0x40004400

080003b0 <uart2_tx_init>:

void uart2_tx_init(void){
 80003b0:	b580      	push	{r7, lr}
 80003b2:	af00      	add	r7, sp, #0

	RCC->AHB1ENR |= GPIOAEN;
 80003b4:	4b20      	ldr	r3, [pc, #128]	@ (8000438 <uart2_tx_init+0x88>)
 80003b6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80003b8:	4a1f      	ldr	r2, [pc, #124]	@ (8000438 <uart2_tx_init+0x88>)
 80003ba:	f043 0301 	orr.w	r3, r3, #1
 80003be:	6313      	str	r3, [r2, #48]	@ 0x30
	GPIOA->MODER &=~(1U<<4);
 80003c0:	4b1e      	ldr	r3, [pc, #120]	@ (800043c <uart2_tx_init+0x8c>)
 80003c2:	681b      	ldr	r3, [r3, #0]
 80003c4:	4a1d      	ldr	r2, [pc, #116]	@ (800043c <uart2_tx_init+0x8c>)
 80003c6:	f023 0310 	bic.w	r3, r3, #16
 80003ca:	6013      	str	r3, [r2, #0]
    GPIOA->MODER |=(1U<<5);
 80003cc:	4b1b      	ldr	r3, [pc, #108]	@ (800043c <uart2_tx_init+0x8c>)
 80003ce:	681b      	ldr	r3, [r3, #0]
 80003d0:	4a1a      	ldr	r2, [pc, #104]	@ (800043c <uart2_tx_init+0x8c>)
 80003d2:	f043 0320 	orr.w	r3, r3, #32
 80003d6:	6013      	str	r3, [r2, #0]
    GPIOA->AFR[0] |=(1U<<8);
 80003d8:	4b18      	ldr	r3, [pc, #96]	@ (800043c <uart2_tx_init+0x8c>)
 80003da:	6a1b      	ldr	r3, [r3, #32]
 80003dc:	4a17      	ldr	r2, [pc, #92]	@ (800043c <uart2_tx_init+0x8c>)
 80003de:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80003e2:	6213      	str	r3, [r2, #32]
	GPIOA->AFR[0] |=(1U<<9);
 80003e4:	4b15      	ldr	r3, [pc, #84]	@ (800043c <uart2_tx_init+0x8c>)
 80003e6:	6a1b      	ldr	r3, [r3, #32]
 80003e8:	4a14      	ldr	r2, [pc, #80]	@ (800043c <uart2_tx_init+0x8c>)
 80003ea:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80003ee:	6213      	str	r3, [r2, #32]
    GPIOA->AFR[0] |=(1U<<10);
 80003f0:	4b12      	ldr	r3, [pc, #72]	@ (800043c <uart2_tx_init+0x8c>)
 80003f2:	6a1b      	ldr	r3, [r3, #32]
 80003f4:	4a11      	ldr	r2, [pc, #68]	@ (800043c <uart2_tx_init+0x8c>)
 80003f6:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 80003fa:	6213      	str	r3, [r2, #32]
    GPIOA->AFR[0] &=~(1U<<11);
 80003fc:	4b0f      	ldr	r3, [pc, #60]	@ (800043c <uart2_tx_init+0x8c>)
 80003fe:	6a1b      	ldr	r3, [r3, #32]
 8000400:	4a0e      	ldr	r2, [pc, #56]	@ (800043c <uart2_tx_init+0x8c>)
 8000402:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8000406:	6213      	str	r3, [r2, #32]

    RCC->APB1ENR |= USART2EN;
 8000408:	4b0b      	ldr	r3, [pc, #44]	@ (8000438 <uart2_tx_init+0x88>)
 800040a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800040c:	4a0a      	ldr	r2, [pc, #40]	@ (8000438 <uart2_tx_init+0x88>)
 800040e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000412:	6413      	str	r3, [r2, #64]	@ 0x40

    usrt_set_baudrate(USART2,APB1_CLK, UART_BAUDRATE);
 8000414:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 8000418:	4909      	ldr	r1, [pc, #36]	@ (8000440 <uart2_tx_init+0x90>)
 800041a:	480a      	ldr	r0, [pc, #40]	@ (8000444 <uart2_tx_init+0x94>)
 800041c:	f000 f814 	bl	8000448 <usrt_set_baudrate>

    USART2->CR1 = CR1_TE;
 8000420:	4b08      	ldr	r3, [pc, #32]	@ (8000444 <uart2_tx_init+0x94>)
 8000422:	2208      	movs	r2, #8
 8000424:	60da      	str	r2, [r3, #12]

    USART2->CR1 |= CR1_UE;
 8000426:	4b07      	ldr	r3, [pc, #28]	@ (8000444 <uart2_tx_init+0x94>)
 8000428:	68db      	ldr	r3, [r3, #12]
 800042a:	4a06      	ldr	r2, [pc, #24]	@ (8000444 <uart2_tx_init+0x94>)
 800042c:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8000430:	60d3      	str	r3, [r2, #12]
}
 8000432:	bf00      	nop
 8000434:	bd80      	pop	{r7, pc}
 8000436:	bf00      	nop
 8000438:	40023800 	.word	0x40023800
 800043c:	40020000 	.word	0x40020000
 8000440:	00f42400 	.word	0x00f42400
 8000444:	40004400 	.word	0x40004400

08000448 <usrt_set_baudrate>:


    USART2->CR1 |= CR1_UE;
}

static void usrt_set_baudrate(USART_TypeDef *USARTx,uint32_t PeriphClk,uint32_t Baudrate){
 8000448:	b580      	push	{r7, lr}
 800044a:	b084      	sub	sp, #16
 800044c:	af00      	add	r7, sp, #0
 800044e:	60f8      	str	r0, [r7, #12]
 8000450:	60b9      	str	r1, [r7, #8]
 8000452:	607a      	str	r2, [r7, #4]
	USARTx->BRR = compute_usrt_bd(PeriphClk,Baudrate);
 8000454:	6879      	ldr	r1, [r7, #4]
 8000456:	68b8      	ldr	r0, [r7, #8]
 8000458:	f000 f808 	bl	800046c <compute_usrt_bd>
 800045c:	4603      	mov	r3, r0
 800045e:	461a      	mov	r2, r3
 8000460:	68fb      	ldr	r3, [r7, #12]
 8000462:	609a      	str	r2, [r3, #8]
}
 8000464:	bf00      	nop
 8000466:	3710      	adds	r7, #16
 8000468:	46bd      	mov	sp, r7
 800046a:	bd80      	pop	{r7, pc}

0800046c <compute_usrt_bd>:

static uint16_t compute_usrt_bd(uint32_t PeriphClk, uint32_t Baudrate){
 800046c:	b480      	push	{r7}
 800046e:	b083      	sub	sp, #12
 8000470:	af00      	add	r7, sp, #0
 8000472:	6078      	str	r0, [r7, #4]
 8000474:	6039      	str	r1, [r7, #0]
	return ((PeriphClk + (Baudrate/2U))/Baudrate);
 8000476:	683b      	ldr	r3, [r7, #0]
 8000478:	085a      	lsrs	r2, r3, #1
 800047a:	687b      	ldr	r3, [r7, #4]
 800047c:	441a      	add	r2, r3
 800047e:	683b      	ldr	r3, [r7, #0]
 8000480:	fbb2 f3f3 	udiv	r3, r2, r3
 8000484:	b29b      	uxth	r3, r3

}
 8000486:	4618      	mov	r0, r3
 8000488:	370c      	adds	r7, #12
 800048a:	46bd      	mov	sp, r7
 800048c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000490:	4770      	bx	lr
	...

08000494 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000494:	480d      	ldr	r0, [pc, #52]	@ (80004cc <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000496:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000498:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800049c:	480c      	ldr	r0, [pc, #48]	@ (80004d0 <LoopForever+0x6>)
  ldr r1, =_edata
 800049e:	490d      	ldr	r1, [pc, #52]	@ (80004d4 <LoopForever+0xa>)
  ldr r2, =_sidata
 80004a0:	4a0d      	ldr	r2, [pc, #52]	@ (80004d8 <LoopForever+0xe>)
  movs r3, #0
 80004a2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80004a4:	e002      	b.n	80004ac <LoopCopyDataInit>

080004a6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80004a6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80004a8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80004aa:	3304      	adds	r3, #4

080004ac <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80004ac:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80004ae:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80004b0:	d3f9      	bcc.n	80004a6 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80004b2:	4a0a      	ldr	r2, [pc, #40]	@ (80004dc <LoopForever+0x12>)
  ldr r4, =_ebss
 80004b4:	4c0a      	ldr	r4, [pc, #40]	@ (80004e0 <LoopForever+0x16>)
  movs r3, #0
 80004b6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80004b8:	e001      	b.n	80004be <LoopFillZerobss>

080004ba <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80004ba:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80004bc:	3204      	adds	r2, #4

080004be <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80004be:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80004c0:	d3fb      	bcc.n	80004ba <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80004c2:	f000 f811 	bl	80004e8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80004c6:	f7ff fe87 	bl	80001d8 <main>

080004ca <LoopForever>:

LoopForever:
  b LoopForever
 80004ca:	e7fe      	b.n	80004ca <LoopForever>
  ldr   r0, =_estack
 80004cc:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 80004d0:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80004d4:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 80004d8:	08000570 	.word	0x08000570
  ldr r2, =_sbss
 80004dc:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 80004e0:	2000001c 	.word	0x2000001c

080004e4 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80004e4:	e7fe      	b.n	80004e4 <ADC_IRQHandler>
	...

080004e8 <__libc_init_array>:
 80004e8:	b570      	push	{r4, r5, r6, lr}
 80004ea:	4d0d      	ldr	r5, [pc, #52]	@ (8000520 <__libc_init_array+0x38>)
 80004ec:	4c0d      	ldr	r4, [pc, #52]	@ (8000524 <__libc_init_array+0x3c>)
 80004ee:	1b64      	subs	r4, r4, r5
 80004f0:	10a4      	asrs	r4, r4, #2
 80004f2:	2600      	movs	r6, #0
 80004f4:	42a6      	cmp	r6, r4
 80004f6:	d109      	bne.n	800050c <__libc_init_array+0x24>
 80004f8:	4d0b      	ldr	r5, [pc, #44]	@ (8000528 <__libc_init_array+0x40>)
 80004fa:	4c0c      	ldr	r4, [pc, #48]	@ (800052c <__libc_init_array+0x44>)
 80004fc:	f000 f818 	bl	8000530 <_init>
 8000500:	1b64      	subs	r4, r4, r5
 8000502:	10a4      	asrs	r4, r4, #2
 8000504:	2600      	movs	r6, #0
 8000506:	42a6      	cmp	r6, r4
 8000508:	d105      	bne.n	8000516 <__libc_init_array+0x2e>
 800050a:	bd70      	pop	{r4, r5, r6, pc}
 800050c:	f855 3b04 	ldr.w	r3, [r5], #4
 8000510:	4798      	blx	r3
 8000512:	3601      	adds	r6, #1
 8000514:	e7ee      	b.n	80004f4 <__libc_init_array+0xc>
 8000516:	f855 3b04 	ldr.w	r3, [r5], #4
 800051a:	4798      	blx	r3
 800051c:	3601      	adds	r6, #1
 800051e:	e7f2      	b.n	8000506 <__libc_init_array+0x1e>
 8000520:	08000568 	.word	0x08000568
 8000524:	08000568 	.word	0x08000568
 8000528:	08000568 	.word	0x08000568
 800052c:	0800056c 	.word	0x0800056c

08000530 <_init>:
 8000530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000532:	bf00      	nop
 8000534:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000536:	bc08      	pop	{r3}
 8000538:	469e      	mov	lr, r3
 800053a:	4770      	bx	lr

0800053c <_fini>:
 800053c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800053e:	bf00      	nop
 8000540:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000542:	bc08      	pop	{r3}
 8000544:	469e      	mov	lr, r3
 8000546:	4770      	bx	lr
